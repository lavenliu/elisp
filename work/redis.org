#+TITLE: Redis
#+AUTHOR: LavenLiu
#+DATE: 2015-12-04
#+EMAIL: ldczz2008@163.com 

#+STARTUP: OVERVIEW
#+TAGS: OFFICE(o) HOME(h) PROJECT(p) CHANGE(c) REPORT(r) MYSELF(m) 
#+TAGS: PROBLEM(P) INTERRUPTTED(i) RESEARCH(R)
#+SEQ_TODO: TODO(t)  STARTED(s) WAITING(W) | DONE(d) CANCELLED(C) DEFERRED(f)
#+COLUMNS: %40ITEM(Details) %TAGS(Context) %7TODO(To Do) %5Effort(Time){:} %6CLOCKSUM{Total}

#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[top=2.1cm,bottom=2.1cm,left=2.1cm,right=2.1cm]{geometry}
#+LaTeX_HEADER: \setmainfont[Mapping=tex-text]{Times New Roman}
#+LaTeX_HEADER: \setsansfont[Mapping=tex-text]{Tahoma}
#+LaTeX_HEADER: \setmonofont{Courier New}
#+LaTeX_HEADER: \setCJKmainfont[BoldFont={Adobe Heiti Std},ItalicFont={Adobe Kaiti Std}]{Adobe Song Std}
#+LaTeX_HEADER: \setCJKsansfont{Adobe Heiti Std}
#+LaTeX_HEADER: \setCJKmonofont{Adobe Fangsong Std}
#+LaTeX_HEADER: \punctstyle{hangmobanjiao}
#+LaTeX_HEADER: \usepackage{color,graphicx}
#+LaTeX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{colortbl}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage[bf,small,indentafter,pagestyles]{titlesec}

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style2.css" />

#+OPTIONS: ^:nil
#+OPTIONS: tex:t

* Redis
  Redis是一个开源的、使用C语言编写的、支持网络交互的、可基于内存也可持
  久化的Key-Value数据库。

  Redis默认会连接127.0.0.1的监听端口：6379。
* 测试环境
  | 主机                    |             IP | 备注  |
  |-------------------------+----------------+-------|
  | linux-node1.example.com | 192.168.20.129 | kvm01 |
  | linux-node2.example.com | 192.168.20.130 | kvm02 |
* Redis与Memcached对比
  | 对比点   | Memcached       | Redis           |
  |----------+-----------------+-----------------|
  | 类型     | Key-Value数据库 | Key-Value数据库 |
  | 过期策略 | 支持            | 支持            |
  | 数据类型 | 单一数据类型    | 五种数据类型    |
  | 持久化   | 不支持          | 支持            |
  | 主从复制 | 不支持          | 支持            |
  | 虚拟内存 | 不支持          | 支持            |
* 五种数据类型
  每种数据类型都有相应的操作命令，所以不同数据类型应使用相对应的命令。
  不可混乱操作。字符串的SET操作指令是终极指令，任何被它操作过的key，
  其key的值类型就会变为字符串。
** 字符串类型
   字符串类型的操作指令：
   + SET
	 #+BEGIN_SRC sh
	 > SET laven liu
	 > SET laven liu,cc
	 > SET laven liu
	 > APPEND laven cc
	 > GET laven
	 #+END_SRC
   + GET
   + DEL
   + APPEND
   + STRLEN
	 #+BEGIN_SRC sh
	 > STRLEN laven
	 #+END_SRC
   + MSET
	 #+BEGIN_SRC sh
	 > MSET key1 v1 key2 v2 key3 v3
	 > GET key1
	 > GET key2
	 > GET key3
	 #+END_SRC
   + MGET
	 #+BEGIN_SRC sh
	 > MGET key1 key2 key3
	 1) "v1"
	 2) "v2"
	 3) "v3"
	 #+END_SRC
   + INCR
	 #+BEGIN_SRC sh
	 > INCR num
	 > INCR num
	 > INCR num
	 > INCR num
	 > GET num
	 #+END_SRC
   + INCRBY
	 #+BEGIN_SRC sh
	 > INCRBY num 10
	 > GET num
	 > INCRBY num 10
	 > GET num
	 #+END_SRC
   + DECR
   + DECRBY
   + INCRBYFLOAT
	 #+BEGIN_SRC sh
	 > INCRBYFLOAT key 0.1
	 > INCRBYFLOAT key 0.1
	 > GET key
	 #+END_SRC
** 散列类型
   命令语法格式：
   #+BEGIN_EXAMPLE
   HSET key field value
   HGET key field
   HMSET key field value [field value ...]
   HMGET key field [field ...]
   HGETALL key
   HDEL key field
   HEXISTS key field
   #+END_EXAMPLE

   使用示例：
   #+BEGIN_EXAMPLE
   > HSET cellphone name iphone4s
   > HSET cellphone color white
   > HSET cellphone price  1999
   > HGET cellphone name
   "iphone4s"
   > HGET cellphone color
   "white"
   > HGETALL cellphone
   1) "name"
   2) "iphone4s"
   3) "color"
   4) "white"
   5) "price"
   6) "1999"

   > HMSET computer name thinkpad color black price 6588
   > HGETALL computer
   1) "name"
   2) "thinkpad"
   3) "color"
   4) "black"
   5) "price"
   6) "6588"
   > HSET computer model E450
   > HGETALL computer
   1) "name"
   2) "thinkpad"
   3) "color"
   4) "black"
   5) "price"
   6) "6588"
   7) "model"
   8) "E450"

   > HDEL computer model
   > HGETALL computer
   1) "name"
   2) "thinkpad"
   3) "color"
   4) "black"
   5) "price"
   6) "6588"
   #+END_EXAMPLE
** 列表类型
   存储是一个有序的字符串列表。(双向的链表，两端都可以进行操作)

   命令语法格式：
   #+BEGIN_EXAMPLE
   LPUSH key value [value ...]
   RPUSH key value [value ...]
   LLEN key
   LPOP key
   RPOP key
   LRANGE key start stop
   LREM key count value
   LTRIM key index1 index2
   LINDEX key index
   #+END_EXAMPLE

   使用示例： 
   #+BEGIN_EXAMPLE
   > LPUSH num 0
   > LPUSH num 1
   > LPUSH num 2
   > RPUSH num 3

   # 现在num的值为 : -> 2 1 0 3
   > LRANGE num 0 -1
   1) "2"
   2) "1"
   3) "0"
   4) "3"
   > LLEN num
   (integer) 4

   > LPOP num
   "2"

   > LLEN num
   (integer) 3

   > RPOP num
   "3"
   
   > LRANGE num 0 -1
   1) "1"
   2) "0"
   3) "3"
   > LRANGE num 0 1
   1) "1"
   2) "0"
   > LPUSH num 2
   > RPUSH 5
   > LRANGE num 0 -1

   > LINDEX num -1

   > LTRIM num 0 2
   > LRANGE num 0 -1
   #+END_EXAMPLE
** 集合类型
   集合也是无序的。

   命令语法格式：
   #+BEGIN_EXAMPLE
   SADD key member [member ...]
   SREM key member [member ...]
   SMEMBERS key
   SISMEMBER key member
   SDIFF key [key ...]
   SINTER key [key ...]
   SUNION key [key ...]
   #+END_EXAMPLE

   使用示例：
   #+BEGIN_EXAMPLE
   # 往集合set1里添加a，b，c数据
   > SADD set1 a b c
   (integer) 3
   > SADD set2 b c d
   (integer) 3

   # 查看结合set1中的数据
   > SMEMBERS set1
   1) "c"
   2) "a"
   3) "b"
   > SMEMBERS set2
   1) "c"
   2) "d"
   3) "b"
   
   # 判断元素b是否属于集合set1的成员，返回值不为0，说明存在
   > SISMEMBER set1 b
   (integer) 1

   # 集合set1与集合set2的差集，set1-set2
   > SDIFF set1 set2
   1) "a"
   
   # 集合set2与集合set2的差集，set2-set1
   > SDIFF set2 set1
   1) "d"

   # 集合set1与集合set2的交集
   > SINTER set1 set2
   1) "c"
   2) "b"

   # 集合set1与集合set2的并集
   > SUNION set1 set2
   1) "c"
   2) "d"
   3) "a"
   4) "b"
   #+END_EXAMPLE
** 有序集合
   为每一个元素设置一个分数，按照分数进行排序。

   命令语法格式：
   #+BEGIN_EXAMPLE
   ZADD key score member # 增加元素并设置分数
   ZSCORE key member     # 获取元素的分数
   ZRANGE key start stop [WITHSCORES]
   ZRANGEBYSCORE key min max
   #+END_EXAMPLE

   使用示例：
   #+BEGIN_EXAMPLE
   > ZADD ordered 60 a
   (integer) 1
   > ZADD ordered 65 b
   (integer) 1
   > ZADD ordered 70 c 75 d
   (integer) 2
   > ZSCORE ordered b
   "65"
   > ZRANGE ordered 0 -1
   1) "a"
   2) "b"
   3) "c"
   4) "d"
   #+END_EXAMPLE
* 常用命令
  | 命令   | 说明            |
  |--------+-----------------|
  | SET    | 设置Key         |
  | GET    | 获取Key的值     |
  | EXISTS | 判断Key是否存在 |
  | KEYS   | 显示所有的key   |
  | DEL    | 删除指定的Key   |
  | TYPE   | 获取Key的类型   |

  redis连接方式：
  #+BEGIN_SRC sh
  redis-cli -h 192.168.20.129 -p 6379
  > SET laven liu
  > GET laven
  > SET laven1 liu1
  > SET laven2 liu2
  > KEYS *
  1) "laven1"
  2) "laven2"
  3) "laven"

  # 判断key为laven是否存在，返回值不为0，说明存在
  > EXISTS laven
  (integer) 1

  # 判断key为liu的数据是否存在，返回值为0，说明不存在
  > EXISTS liu
  (integer) 0

  # 删除key为laven的数据，返回值为1，说明存在key为laven的数据，并成功删除
  > DEL laven
  (integer) 1

  # 返回值为0，说明不存在key为laven的数据，并未执行删除操作
  > DEL laven
  (integer) 0

  # 查看key为laven1的数据类型
  > TYPE laven1
  string

  > INFO
  db0:keys=2,expires=0

  # 使用select选择(切换)数据库
  > SELECT 1
  > SET db1key lavenliu

  # 再次使用info查看
  > INFO
  db0:keys=2,expires=0
  db1:keys=1,expires=0
  #+END_SRC
* 发布与订阅
  打开多个终端，一个终端进行如下操作：
  #+BEGIN_SRC sh
  # 订阅操作
  > SUBSCRIBE hehe
  #+END_SRC

  另一个终端进行如下操作：
  #+BEGIN_SRC sh
  # 发布操作
  > PUBLISH hehe world
  #+END_SRC
* Redis的数据持久化
  两种方式的数据持久化(默认的是RDB形式)：
  + RDB
	#+BEGIN_EXAMPLE
	在指定的时间间隔内，把内存中的数据快照一下放到本地。
	#+END_EXAMPLE
  + AOF
	#+BEGIN_EXAMPLE
	把所有端执行的命令记录下来。
	#+END_EXAMPLE

  Redis的配置文件：
  #+BEGIN_EXAMPLE
  # Save DB on disk
  save 900 1    # 如果在900秒内，至少有1个key发生变化，  就做一次快照
  save 300 10   # 如果在300秒内，至少有10个key发生变化， 就做一次快照
  save 60 10000 # 如果在60秒内， 至少有1万个key发生变化，就做一次快照
  这三句是或的关系

  # 数据存放在
  dbfilename dump.rdb

  # 数据存放目录
  dir /var/lib/redis/
  #+END_EXAMPLE

  一个示例：
  #+BEGIN_EXAMPLE
  > SET key 1
  > SAVE
  > SET key 2
  > BGSAVE
  #+END_EXAMPLE

  使用SAVE和BGSAVE命令把内存中的数据进行保存的操作。

  AOF形式的持久化：
  #+BEGIN_EXAMPLE
  appendonly yes  # 开启AOF
  appendfilename "appendonly.aof"
  # 文件存放在配置文件中的dir目录下面
  #+END_EXAMPLE
* Redis主从
  在一台机器上启用两个Redis，一个监听在6379端口，一个监听在6380端口。
  需要两个配置文件，如/etc/redis-6379.conf与/etc/redis-6380.conf

  一个主服务器可以有多个从服务器，从服务器还可以有从服务器。

  Redis主从原理：
  #+BEGIN_EXAMPLE
  当建立一个从服务器时，从服务器会向主服务器发送一个sync命令，主服务
  器会在执行BGSAVE，然后把rdb文件同步给从服务器。
  从服务器是只读的（从2.6版本开始）。
  #+END_EXAMPLE

  在6380端口上的redis进行设置：
  #+BEGIN_SRC sh
  > slaveof 127.0.0.1 6379
  > info
  role:slave
  #+END_SRC

  在6379端口上的redis进行操作：
  #+BEGIN_SRC sh
  > info
  role:master
  slave0:127.0.0.1,46600,online
  #+END_SRC
* Redis集群
  Redis集群有四种方案：
  1. 客户端分片
	 #+BEGIN_EXAMPLE
	 优点：比较灵活
	 缺点：
	 #+END_EXAMPLE
  2. 代理分片
  3. Redis Cluster
  4. Codis
** 客户端分片
   这种方案将分片工作放在业务程序端，程序代码根据预先设置的路由规则，直接对多个Redis实例进行分布式访问。
   这样的好处是，不依赖于第三方分布式中间件，实现方法和代码都自己掌控，可随时调整，不用担心踩到坑。

   客户端分片实际上是一种静态分片技术。Redis实例的增减，都得手工调整分片程序。基于此分片机制的开源产品，现在仍不多见。

   这种分片机制的性能比代理式更好（少了一个中间分发环节）。但缺点是升级麻烦，
   对研发人员的个人依赖性强——需要有较强的程序开发能力做后盾。如果主力程序员离职，可能新的负责人，会选择重写一遍。

   所以，这种方式下，可运维性较差。出现故障，定位和解决都得研发和运维配合着解决，故障时间变长。

   这种方案，难以进行标准化运维，不太适合中小公司（除非有足够的DevOPS）。
** 代理分片
   这种方案，将分片工作交给专门的代理程序来做。代理程序接收到来自业务程序的数据请求，根据路由规则，
   将这些请求分发给正确的Redis实例并返回给业务程序。

   拓扑图：redis_proxy.jpg

   这种机制下，一般会选用第三方代理程序（而不是自己研发），因为后端有多个Redis实例，所以这类程序又称为分布式中间件。

   这样的好处是，业务程序不用关心后端Redis实例，运维起来也方便。虽然会因此带来些性能损耗，但对于Redis这种内存读写型应用，相对而言是能容忍的。

   这是我们推荐的集群实现方案。像基于该机制的开源产品Twemproxy，便是其中代表之一，应用非常广泛。
** Redis Cluster
   在这种机制下，没有中心节点（和代理模式的重要不同之处）。所以，一切开心和不开心的事情，都将基于此而展开。

   Redis Cluster将所有Key映射到16384个Slot中，集群中每个Redis实例负责一部分，业务程序通过集成的Redis Cluster客户端进行操作。
   客户端可以向任一实例发出请求，如果所需数据不在该实例中，则该实例引导客户端自动去对应实例读写数据。

   Redis Cluster的成员管理（节点名称、IP、端口、状态、角色）等，都通过节点之间两两通讯，定期交换并更新。

   由此可见，这是一种非常“重”的方案。已经不是Redis单实例的“简单、可依赖”了。可能这也是延期多年之后，才近期发布的原因之一。

   这令人想起一段历史。因为Memcache不支持持久化，所以有人写了一个Membase，后来改名叫Couchbase，说是支持Auto Rebalance，好几年了，至今都没多少家公司在使用。

   这是个令人忧心忡忡的方案。为解决仲裁等集群管理的问题，Oracle RAC还会使用存储设备的一块空间。而Redis Cluster，是一种完全的去中心化……

   本方案目前不推荐使用，从了解的情况来看，线上业务的实际应用也并不多见。

  创建8个集群节点：
  #+BEGIN_EXAMPLE
  cd /opt
  mkdir `seq 7001 7008`
  cp /etc/redis_6380.conf .
  vim redis_6380.conf 
  #+END_EXAMPLE

  redis配置文件：
  #+BEGIN_EXAMPLE
  daemonize yes
  pidfile /var/run/redis_7001.pid
  port 7001
  cluster-enabled yes
  cluster-config-file nodes.conf
  cluster-node-timeout 5000
  tcp-backlog 511
  bind 192.168.56.101
  timeout 0
  tcp-keepalive 0
  loglevel notice
  logfile "/var/log/redis/redis-7001.log"
  databases 16
  save 900 1
  save 300 10
  save 60 10000
  stop-writes-on-bgsave-error yes
  rdbcompression yes
  rdbchecksum yes
  dbfilename dump_7001.rdb
  dir /opt/7001
  slave-serve-stale-data yes
  slave-read-only yes
  repl-diskless-sync no
  repl-diskless-sync-delay 5
  repl-disable-tcp-nodelay no
  slave-priority 100
  appendonly yes
  appendfilename "appendonly_7001.aof"
  appendfsync everysec
  no-appendfsync-on-rewrite no
  auto-aof-rewrite-percentage 100
  auto-aof-rewrite-min-size 64mb
  aof-load-truncated yes
  lua-time-limit 5000
  slowlog-log-slower-than 10000
  slowlog-max-len 128
  latency-monitor-threshold 0
  notify-keyspace-events ""
  hash-max-ziplist-entries 512
  hash-max-ziplist-value 64
  list-max-ziplist-entries 512
  list-max-ziplist-value 64
  set-max-intset-entries 512
  zset-max-ziplist-entries 128
  zset-max-ziplist-value 64
  hll-sparse-max-bytes 3000
  activerehashing yes
  client-output-buffer-limit normal 0 0 0
  client-output-buffer-limit slave 256mb 64mb 60
  client-output-buffer-limit pubsub 32mb 8mb 60
  hz 10
  aof-rewrite-incremental-fsync yes
  #+END_EXAMPLE

  #+BEGIN_SRC sh
  # 批量启动redis-server
  # cd /opt
  # ls
  7001  7002  7003  7004  7005  7006  7007  7008
  # for i in {7001..7008} ; do /usr/local/redis/bin/redis-server ./${i}/redis.conf ; done 
  # 查看端口监听情况
  # netstat -antup |grep 700
  tcp        0      0 192.168.56.101:7005         0.0.0.0:*                   LISTEN      2948/redis-server 1 
  tcp        0      0 192.168.56.101:7006         0.0.0.0:*                   LISTEN      2950/redis-server 1 
  tcp        0      0 192.168.56.101:7007         0.0.0.0:*                   LISTEN      2952/redis-server 1 
  tcp        0      0 192.168.56.101:7008         0.0.0.0:*                   LISTEN      2954/redis-server 1 
  tcp        0      0 192.168.56.101:17001        0.0.0.0:*                   LISTEN      2940/redis-server 1 
  tcp        0      0 192.168.56.101:17002        0.0.0.0:*                   LISTEN      2942/redis-server 1 
  tcp        0      0 192.168.56.101:17003        0.0.0.0:*                   LISTEN      2944/redis-server 1 
  tcp        0      0 192.168.56.101:17004        0.0.0.0:*                   LISTEN      2946/redis-server 1 
  tcp        0      0 192.168.56.101:17005        0.0.0.0:*                   LISTEN      2948/redis-server 1 
  tcp        0      0 192.168.56.101:17006        0.0.0.0:*                   LISTEN      2950/redis-server 1 
  tcp        0      0 192.168.56.101:17007        0.0.0.0:*                   LISTEN      2952/redis-server 1 
  tcp        0      0 192.168.56.101:17008        0.0.0.0:*                   LISTEN      2954/redis-server 1 
  tcp        0      0 192.168.56.101:7001         0.0.0.0:*                   LISTEN      2940/redis-server 1 
  tcp        0      0 192.168.56.101:7002         0.0.0.0:*                   LISTEN      2942/redis-server 1 
  tcp        0      0 192.168.56.101:7003         0.0.0.0:*                   LISTEN      2944/redis-server 1 
  tcp        0      0 192.168.56.101:7004         0.0.0.0:*                   LISTEN      2946/redis-server 1
  #+END_SRC

  启动没有问题，接下来安装ruby的测试工具：
  #+BEGIN_SRC sh
  # yum install -y ruby rubygems
  # gem install redis
  # cp /usr/local/src/redis-3.0.6/src/redis-trib.rb /bin/redis-trib
  # redis-trib create --replicas 1 192.168.56.101:7001 \
  192.168.56.101:7002 \
  192.168.56.101:7003 \
  192.168.56.101:7004 \
  192.168.56.101:7005 \
  192.168.56.101:7006

  >>> Creating cluster
  >>> Performing hash slots allocation on 6 nodes...
  Using 3 masters:
  192.168.56.101:7001 # master
  192.168.56.101:7002 # master
  192.168.56.101:7003 # master
  Adding replica 192.168.56.101:7004 to 192.168.56.101:7001 # 7004为7001的从
  Adding replica 192.168.56.101:7005 to 192.168.56.101:7002 # 7005为7002的从
  Adding replica 192.168.56.101:7006 to 192.168.56.101:7003 # 7006为7003的从
  M: e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001
	 slots:0-5460 (5461 slots) master
  M: f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002
	 slots:5461-10922 (5462 slots) master
  M: 3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003
	 slots:10923-16383 (5461 slots) master
  S: ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004
	 replicates e86b430867b4bdaeae476410b06d75a518f8fab7
  S: 5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005
	 replicates f0f83a89033033dbc1a35bd01ca613f107542e41
  S: 7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006
	 replicates 3fd595eaac832dce40953f9146edf8411d8c2206
  Can I set the above configuration? (type 'yes' to accept): yes # 输入"yes"
  >>> Nodes configuration updated
  >>> Assign a different config epoch to each node
  >>> Sending CLUSTER MEET messages to join the cluster
  Waiting for the cluster to join...
  >>> Performing Cluster Check (using node 192.168.56.101:7001)
  M: e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001
	 slots:0-5460 (5461 slots) master
  M: f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002
	 slots:5461-10922 (5462 slots) master
  M: 3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003
	 slots:10923-16383 (5461 slots) master
  M: ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004
	 slots: (0 slots) master
	 replicates e86b430867b4bdaeae476410b06d75a518f8fab7
  M: 5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005
	 slots: (0 slots) master
	 replicates f0f83a89033033dbc1a35bd01ca613f107542e41
  M: 7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006
	 slots: (0 slots) master
	 replicates 3fd595eaac832dce40953f9146edf8411d8c2206
  [OK] All nodes agree about slots configuration.
  >>> Check for open slots...
  >>> Check slots coverage...
  [OK] All 16384 slots covered. 
  #+END_SRC

  集群创建完毕，使用redis-cli进行连接，注意使用"-c"选项：
  #+BEGIN_SRC sh
  # cd /usr/local/redis/bin/
  # ./redis-cli -c -h 192.168.56.101 -p 7001
  # ./redis-cli -c -h 192.168.56.101 -p 7002
  # ./redis-cli -c -h 192.168.56.101 -p 7003
  # ./redis-cli -c -h 192.168.56.101 -p 7004
  # ./redis-cli -c -h 192.168.56.101 -p 7005
  # ./redis-cli -c -h 192.168.56.101 -p 7006
  # ./redis-cli -c -h 192.168.56.101 -p 7001
  192.168.56.101:7001> SET key1 1 
  -> Redirected to slot [9189] located at 192.168.56.101:7002
  OK
  192.168.56.101:7002> KEYS *
  1) "key1"
  192.168.56.101:7002> SET key2 2
  -> Redirected to slot [4998] located at 192.168.56.101:7001
  OK
  192.168.56.101:7001>
  192.168.56.101:7001> CLUSTER INFO
  cluster_state:ok
  cluster_slots_assigned:16384
  cluster_slots_ok:16384
  cluster_slots_pfail:0
  cluster_slots_fail:0
  cluster_known_nodes:6
  cluster_size:3
  cluster_current_epoch:6
  cluster_my_epoch:1
  cluster_stats_messages_sent:225884
  cluster_stats_messages_received:225884
  192.168.56.101:7001> CLUSTER NODES
  7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006 slave 3fd595eaac832dce40953f9146edf8411d8c2206 0 1453135169247 6 connected
  ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004 slave e86b430867b4bdaeae476410b06d75a518f8fab7 0 1453135169247 4 connected
  e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001 myself,master - 0 0 1 connected 0-5460
  5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005 slave f0f83a89033033dbc1a35bd01ca613f107542e41 0 1453135168243 5 connected
  3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003 master - 0 1453135168745 3 connected 10923-16383
  f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002 master - 0 1453135169747 2 connected 5461-10922
  #+END_SRC

  使用redis-trib向集群中添加节点：
  #+BEGIN_SRC sh
  # redis-trib add-node 192.168.56.101:7007 192.168.56.101:7001
  192.168.56.101:7001> CLUSTER NODES
  7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006 slave 3fd595eaac832dce40953f9146edf8411d8c2206 0 1453135567816 6 connected
  ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004 slave e86b430867b4bdaeae476410b06d75a518f8fab7 0 1453135567314 4 connected
  6f7b48c41b4a541165d62e241bfb8d40ffd73b78 192.168.56.101:7007 master - 0 1453135566311 0 connected
  e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001 myself,master - 0 0 1 connected 0-5460
  5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005 slave f0f83a89033033dbc1a35bd01ca613f107542e41 0 1453135567314 5 connected
  3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003 master - 0 1453135567314 3 connected 10923-16383
  f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002 master - 0 1453135568318 2 connected 5461-10922
  #+END_SRC

  使用redis-trib命令重新分片：
  #+BEGIN_SRC sh
  # redis-trib reshard 192.168.56.101:7007
  # 填写7007的ID"6f7b48c41b4a541165d62e241bfb8d40ffd73b78"
  Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
  Source node #1:all

  Ready to move 500 slots.
  Source nodes:
	M: f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002
  slots:5461-10922 (5462 slots) master
  1 additional replica(s)
	M: 3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003
  slots:10923-16383 (5461 slots) master
  1 additional replica(s)
	M: e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001
  slots:0-5460 (5461 slots) master
  1 additional replica(s)
  Destination node:
	M: 6f7b48c41b4a541165d62e241bfb8d40ffd73b78 192.168.56.101:7007
  slots: (0 slots) master
  0 additional replica(s)
  Do you want to proceed with the proposed reshard plan (yes/no)? yes

  192.168.56.101:7001> CLUSTER NODES
  7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006 slave 3fd595eaac832dce40953f9146edf8411d8c2206 0 1453136052885 6 connected
  ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004 slave e86b430867b4bdaeae476410b06d75a518f8fab7 0 1453136051383 4 connected
  6f7b48c41b4a541165d62e241bfb8d40ffd73b78 192.168.56.101:7007 master - 0 1453136051383 7 connected 0-165 5461-5627 10923-11088
  e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001 myself,master - 0 0 1 connected 166-5460
  5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005 slave f0f83a89033033dbc1a35bd01ca613f107542e41 0 1453136052885 5 connected
  3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003 master - 0 1453136051885 3 connected 11089-16383
  f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002 master - 0 1453136050882 2 connected 5628-10922
  #+END_SRC

  再次添加一个端口为7008的节点，并让其成为端口7007的从，
  #+BEGIN_SRC sh
  # redis-trib add-node 192.168.56.101:7008 192.168.56.101:7001
  192.168.56.101:7001> CLUSTER NODES
  a33ba970f889fd5fd8a02deb7c4f99a5b070ee6a 192.168.56.101:7008 master - 0 1453136398015 0 connected # 多出了一个端口为7008的主节点
  7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006 slave 3fd595eaac832dce40953f9146edf8411d8c2206 0 1453136399019 6 connected
  ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004 slave e86b430867b4bdaeae476410b06d75a518f8fab7 0 1453136398517 4 connected
  6f7b48c41b4a541165d62e241bfb8d40ffd73b78 192.168.56.101:7007 master - 0 1453136397012 7 connected 0-165 5461-5627 10923-11088
  e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001 myself,master - 0 0 1 connected 166-5460
  5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005 slave f0f83a89033033dbc1a35bd01ca613f107542e41 0 1453136398015 5 connected
  3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003 master - 0 1453136397012 3 connected 11089-16383
  f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002 master - 0 1453136399019 2 connected 5628-10922
  # 这时，连接到端口为7008的节点上进行设置
  # ./redis-cli -c -h 192.168.56.101 -p 7008
  192.168.56.101:7008> CLUSTER REPLICATE 6f7b48c41b4a541165d62e241bfb8d40ffd73b78
  192.168.56.102:7008> CLUSTER NODES
  a33ba970f889fd5fd8a02deb7c4f99a5b070ee6a 192.168.56.101:7008 myself,slave 6f7b48c41b4a541165d62e241bfb8d40ffd73b78 0 0 0 connected
  5e34fde4a80c746f99cf5e44300708bd43a3e0b8 192.168.56.101:7005 slave f0f83a89033033dbc1a35bd01ca613f107542e41 0 1453136623843 2 connected
  6f7b48c41b4a541165d62e241bfb8d40ffd73b78 192.168.56.101:7007 master - 0 1453136624344 7 connected 0-165 5461-5627 10923-11088
  7ad350958cdc5f6a44d5535fb67e81878ad8ca24 192.168.56.101:7006 slave 3fd595eaac832dce40953f9146edf8411d8c2206 0 1453136624844 3 connected
  f0f83a89033033dbc1a35bd01ca613f107542e41 192.168.56.101:7002 master - 0 1453136624844 2 connected 5628-10922
  e86b430867b4bdaeae476410b06d75a518f8fab7 192.168.56.101:7001 master - 0 1453136622840 1 connected 166-5460
  ea571867e9cbd6122a58b447594fb5462871a64a 192.168.56.101:7004 slave e86b430867b4bdaeae476410b06d75a518f8fab7 0 1453136623843 1 connected
  3fd595eaac832dce40953f9146edf8411d8c2206 192.168.56.101:7003 master - 0 1453136622840 3 connected 11089-16383
  #+END_SRC
* Redis管理工具
** phpRedisAdmin
   #+BEGIN_SRC sh
   # yum install -y httpd php php-redis
   # cd /var/www/html/
   # git clone https://github.com/erikdubbelboer/phpRedisAdmin.git
   # cd phpRedisAdmin
   # git clone https://github.com/nrk/predis.git vendor
   #+END_SRC
   
   或许需要修改配置文件：
   #+BEGIN_EXAMPLE
   # vim /var/www/html/phpRedisAdmin/include/config.sample.inc.php
	 'servers' => array(
   array(
	 'name'   => '7001', // Optional name.
	 'host'   => '192.168.56.101',
	 'port'   => 7001,
	 'filter' => '*',

	 // Optional Redis authentication.
	 //'auth' => 'redispasswordhere' // Warning: The password is sent in plain-text to the Redis server.
   ),

   array(
	 'name' => '7002',
	 'host' => '192.168.56.101',
	 'port' => 7002
   ),
   #+END_EXAMPLE

   配置完毕，在浏览器里进行访问：http://192.168.56.101/phpRedisAdmin
** rdbtools
   github地址：[[https://github.com/sripathikrishnan/redis-rdb-tools][GitHub源码地址]]
   #+BEGIN_SRC sh
   # pip install rdbtools
   #+END_SRC

   如何使用？
   #+BEGIN_EXAMPLE
   # cd /opt/7001
   # rdb -c memory dump_7001.rdb > memory.csv
   # cat memory.csv
   #+END_EXAMPLE
   内容如下：
   | database | type   | key  | size_in_bytes | encoding | num_elements | len_largest_element |
   |----------+--------+------+---------------+----------+--------------+---------------------|
   |        0 | string | key2 |            77 | string   |            8 |                   8 |
* Redis分布式解决方案
  Codis，项目在github上，https://github.com/wandoulabs/codis
** 安装Codis
*** 安装golang
	 #+BEGIN_SRC sh
yum install -y golang
mkdir /opt/gopath
echo "export GOPATH=/opt/gopath" >> /etc/profile
. /etc/profile
go get -d github.com/wandoulabs/codis
	 #+END_SRC
* Redis文档相关
  Redis中文文档：[[http://redisdoc.com/][Redis中文参考文档]]
