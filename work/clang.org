#+TITLE: C语言编程
#+AUTHOR: LavenLiu
#+DATE: 2015-09-27
#+EMAIL: ldczz2008@163.com 

#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[top=2.1cm,bottom=2.1cm,left=2.1cm,right=2.1cm]{geometry}
#+LaTeX_HEADER: \setmainfont[Mapping=tex-text]{Times New Roman}
#+LaTeX_HEADER: \setsansfont[Mapping=tex-text]{Tahoma}
#+LaTeX_HEADER: \setmonofont{Courier New}
#+LaTeX_HEADER: \setCJKmainfont[BoldFont={Adobe Heiti Std},ItalicFont={Adobe Kaiti Std}]{Adobe Song Std}
#+LaTeX_HEADER: \setCJKsansfont{Adobe Heiti Std}
#+LaTeX_HEADER: \setCJKmonofont{Adobe Fangsong Std}
#+LaTeX_HEADER: \punctstyle{hangmobanjiao}
#+LaTeX_HEADER: \usepackage{color,graphicx}
#+LaTeX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{colortbl}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage[bf,small,indentafter,pagestyles]{titlesec}
#+LaTeX_HEADER: \renewcommand{\baselinestretch}{1.38}
#+LaTeX_HEADER: \setlength{\baselineskip}{20pt}

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style2.css" />

#+OPTIONS: ^:nil

* C语言基本概念
** 一个简单的C程序
   #+BEGIN_SRC C
/*
 * filename: pun.c 
 */

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("To C, or not to C: that is a question.\n");
    return 0;
}
   #+END_SRC

   #+RESULTS:
   | To C | or not to C: that is a question. |

   编辑完毕源代码，接下来就可以把程序转化为机器可以执行的形式。对于C程
   序来说，通常包含下列3个步骤：
   1. *预处理* 首先会把程序送给预处理器（怕热processor）。预处理器执行
      以#开头的命令（通常称为指令，directive）。预处理器有点类似编辑器，
      它可以给程序添加内容，也可以对程序进行修改。
   2. *编译* 修改后的程序现在可以进入编译器（compiler）了。编译器会把
      程序翻译成机器指令（即目标代码：object code）。然而，这样的程序
      还是不可以运行的。
   3. *链接* 在最后一个步骤中，链接器（linker）把由编译器产生的目标代
      码和任何其他附加代码整合在一起，这样才最终产生了完全可执行的程序。
      这些附加代码包括很多程序中用到的库函数（如printf函数）。

   接下来编译和链接pun.c源程序，
   #+BEGIN_SRC sh
gcc -Wall -o pun pun.c
# -Wall选项可以使gcc比平常更彻底地检查程序并且警告可能发生的问题
   #+END_SRC
** 简单程序的通用形式
   上面的pun.c程序，并且由此归纳出一些通用的程序格式。简单的C程序一般具有如下形式：
   #+BEGIN_SRC C
指令
main()
{
	语句
}
   #+END_SRC

   即使是最简单的C程序也依赖3个关键的语言特性：指令（在编译操作前修改
   程序的编辑命令），函数（被命名的可执行代码块，例如main函数）和语句
   （程序运行时执行的命令）。
*** 指令
	在编译C程序之前，预处理器会首先对C程序进行编辑。我们把预处理器执行
	的命令称为指令。下面的指令，
	#+BEGIN_SRC C
#include <stdio.h>
	#+END_SRC
	这条指令说明在编译前把<stdio.h>中的信息“包含”到程序中。<stdio.h>包
	含了关于C标准输入/输出库的信息。

	所有指令都是以字符#开始的。这个字符可以把C程序中的指令和其他代码区
	分开来。默认情况下，指令是一行，在每条指令的结尾既没有分号也没有其他特殊标记。
*** 函数
	函数分为两大类：一类是程序员编写的函数，另一类是则是由C语言的实现
	所提供的函数。后者则可以称为库函数（library function），因为这些函
	数属于一个函数的“库”，而这个库则是由编译器提供的。
*** 语句
	语句是程序运行时执行的命令。C语言规定每条语句都要以分号结尾。对于
	复合语句，由于它们可以连续占用多行，所以很难确定它的结束为止，因此
	用分号来向编译器显示语句的结束位置。但是指令都是一行，因此不要用分号结尾。
** 注释
   每一个程序都应该包含识别信息，即程序名、编写日期、作者、程序的用途
   以及其他内容。C语言把这类信息放在注释中。符号/*标记注释的开始，而符
   号*/则表示注释的结束。例如：
   #+BEGIN_SRC C
/* This is a comment */
   #+END_SRC

   注释几乎可以出现在程序的任何位置上。它既可以单独占行也可以和其他程
   序文本出现在同一行。如下面的程序，
   #+BEGIN_SRC C
/* Name: pun.c                */
/* Purpose: Prints a bad pun. */
/* Author: Laven Liu          */
/* Date written: 2016-03-12   */

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("To C, or not to C: that is the question.\n");
    return 0;
}
   #+END_SRC

   更好的注释应该使用"盒型"注释。
** 变量和赋值
   声明变量，
   #+BEGIN_SRC C
int height;
float profit;
   #+END_SRC

   变量赋值，
   #+BEGIN_SRC C
height = 8;
length = 12;
width = 10;
   #+END_SRC

   一个源程序dweight.c，
   #+BEGIN_SRC C
/* Computes the dimensional weight of a 12x10x8 box */

#include <stdio.h>

int main(int argc, char *argv[])
{
    int height, length, width, volume, weight;

	height = 8;
	length = 12;
	width = 10;
	volume = height * length * width;
	weight = (volume + 165) / 166;

	printf("Dimensions: %dx%dx%d\n", length, width, height);
	printf("Volume (cubic inches): %d\n", volume);
	printf("Dimensional weight (pounds): %d\n", weight);
	
    return 0;
}
   #+END_SRC

   #+RESULTS:
   | Dimensions: | 12x10x8 |           |     |
   | Volume      | (cubic  | inches):  | 960 |
   | Dimensional | weight  | (pounds): |   6 |
*** 初始化
	当程序开始执行时，某些变量会自动设置为零，而大多数变量则不会。
** 读入输入
   可以使用scnaf函数来读入程序的输入。下面是计算箱子的空间重量（改进版），
   #+BEGIN_SRC C
   
   #+END_SRC
** 定义常量
** 标识符
** C语言程序的布局
* 格式化输入/输出
** printf函数
** scanf函数
* 表达式
** 算术运算符
** 赋值运算符
** 自增运算符和自减运算符
** 表达式求值
** 表达式语句
* 选择语句
** 逻辑表达式
** if语句
** switch语句
* 循环
** while语句
** do语句
** for语句
** 退出循环
** 空语句
* 基本类型
  计算机处理的是数字而不是符号。
** 整型
   C语言支持两种根本不同的数值类型：整型和浮点型。整型的值全都是数，而
   浮点型的值则可能还有小数部分。整型又分为两大类：有符号的和无符号的。

   可移植性技巧：为了最大限度保证可移植性，对不超过32767的整数采用
   int(或short int)类型，而对其他的整数采用long int类型。

   1. 十进制常量包含数字0-9，但是一定不能以零开头
   2. 八进制常量只包含数字0-7，而且必须要以零开头
   3. 十六进制常量包含数字0-9和字母a-f，而且总是以0x开头

   八进制和十六进制只是数字书写的另一种形式；它们不会对数字实际存储的
   方式产生影响（整数都是以二进制的形式存储的，而不考虑实际书写的方式）。
   任何时候都可以从一种书写形式切换到另一种书写形式，甚至是混合使用。
** 浮点型
** 字符型
** sizeof运算符
** 类型转换
** 类型定义
* 数组
  标量具有保存单一数据项的能力。C语言也支持聚合变量，这类变量可以存储
  数值的集合。在C语言中一共有两种聚合类型：数组和结构。
** 一维数组
   数组是含有多个数据项的数据结构，并且每个数据项具有相同的数据类型。
   这些数据项被称为元素。数组内可以根据元素所处的位置对其进行单独选择。

   最简单的数组类型就是一维数组，一维数组中的元素一个接一个地编排在单
   独一行内。

   为了声明一个数组，需要说明数组元素的 *类型* 和 *数量* 。例如为了声
   明数组a有10个int型的元素，可以写成：
   #+BEGIN_SRC C
   int a[10];
   #+END_SRC

   数组的元素可以是任意类型；数组的长度可以用任何（整数）常量表达式说
   明。因为在程序后面变化时可能需要调整数组的长度，所以较好的方法是用
   宏来定义数组的长度。
   #+BEGIN_SRC C
   #define N 10
   int a[N];
   #+END_SRC
*** 数组下标
	为了存取特定的数组元素，可以在编写数组名的同时在后边加上一个用方括
	号围绕的整数值（称这是对数组进行下标或索引）。数组元素始终从0开始，
	所以长度为n的数组元素的索引是从0到n-1。

	数组和for循环结合在一起使用。许多程序所包含的for循环都是为了对数组
	中的每个元素执行一些，常用的一些典型操作：
	#+BEGIN_SRC C
for (i = 0; i < N; i++) {
    a[i] = 0; /* clear a */
}

for (i = 0; i < N; i++) {
    scanf("%d", &a[i]); /* reads data into a */
}

for (i = 0; i < N; i++) {
    sum += a[i]; /* sums the element of a */
}
	#+END_SRC
*** 数组初始化
	数组初始化式最通用的格式是一个常量表达式列表，列表用大括号括起来，
	并且内部数值用逗号进行分割，如：
	#+BEGIN_SRC C
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	#+END_SRC
	与其他变量一样，数组也可以在声明时获得一个初始值。如果初始化式比数
	组短，那么数组中剩余的元素赋值为0。例如给全部数组元素初始化为0：
	#+BEGIN_SRC C
int a[10] = {0};
	#+END_SRC

	初始化式完全为空是非法的，所有要在大括号内放一个单独的0。初始化式
	长过要初始化的数组也是非法的。如果显示一个初始化式，那么可以忽略掉
	数组的长度：
	#+BEGIN_SRC C
int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	#+END_SRC
	
	编译器利用初始化式的长度来确定数组的大小。数组始终有元素的固定数量。

	一个例子，检查数组中重复出现的数字，
	#+BEGIN_SRC C
/**
 *   \file repdigit.c
 *   \brief Checks numbers for repeated digits.
 *
 *  Detailed description
 *
 */

#include <stdio.h>

#define TRUE 1
#define FALSE 0

typedef int Bool;

int main(int argc, char *argv[])
{
    Bool     digit_seen[10] = {0};
	int      digit;
	long int n;

	printf("Enter a number: \n");
	scanf("%ld", &n);

	while (n > 0) {
		digit = n % 10;
		if (digit_seen[digit]) {
			break;
		}
		digit_seen[digit] = TRUE;
		n /= 10;
	}

	if (n > 0) {
		printf("Repeated digit\n\n");
	} else {
		printf("No repeated digit\n\n");
	}

    return 0;
}
	#+END_SRC
*** 对数组使用sizeof运算符
	运算符sizeof可以确定数组的大小（字节数）。如果数组a有10个整数，那
	么sizeof(a)可以代表为20（如果整数是16位长）或者40（如果整数是32位
	长）。

	还可以使用sizeof来计算数组元素的大小。用数组的大小除以数组元素的大
	小可以得到数组的长度：
	#+BEGIN_SRC C
	sizeof(a) / sizeof(a[0])
	#+END_SRC
	当需要数组长度时，我们可以采用上述的表达式。例如，数组a的清零操作可以写成如下形式：
	#+BEGIN_SRC C
for (i = 0; i < sizeof(a) / sizeof(a[0]); i++) {
    a[i] = 0;
}
	#+END_SRC
	利用这种技术，即使数组长度在日后需要改变，也不需要改变循环。当然利
	用宏来表示数组的长度也可以获得同样的好处，但是sizeof技术稍微更好一
	些，因为没有宏的名字需要记住（并且可能由此产生错误）。
** 多维数组
* 函数
** 函数的定义与调用
** 函数声明
** 实际参数
** return语句
** 程序终止
** 递归函数
* 程序结构
** 局部变量
** 外部变量
** 程序块
** 作用域
** 构建C程序
* 指针
** 指针变量
** 取地址运算符和间接寻址运算符
** 指针赋值
** 指针作为实际参数
** 指针作为返回值
* 指针和数组
** 指针的算术运算
** 指针用于数组处理
** 用数组名作为指针
** 指针和多维数组
* 字符串
** 字符串字面量
** 字符串变量
** 字符串的读写
** 访问字符串中的字符
** 使用C语言的字符串库
** 字符串惯用法
** 字符串数组
* 预处理器
* 编写大规模程序
** 源文件
** 头文件
** 把程序划分成多个文件
** 构建多文件程序
* 结构、联合和枚举
** 结构变量
** 结构类型
** 数组和结构的嵌套
** 联合
** 枚举
* 指针的高级应用
** 动态存储分配
** 动态分配字符串
** 动态分配数组
** 释放存储
** 链表
** 指向指针的指针
** 指向函数的指针

