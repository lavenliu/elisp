#+TITLE: 项目架构
#+AUTHOR: LavenLiu
#+DATE: 2014-08-20
#+EMAIL: ldczz2008@163.com 

#+STARTUP: OVERVIEW
#+TAGS: OFFICE(o) HOME(h) PROJECT(p) CHANGE(c) REPORT(r) MYSELF(m) 
#+TAGS: PROBLEM(P) INTERRUPTTED(i) RESEARCH(R)
#+SEQ_TODO: TODO(t)  STARTED(s) WAITING(W) | DONE(d) CANCELLED(C) DEFERRED(f)
#+COLUMNS: %40ITEM(Details) %TAGS(Context) %7TODO(To Do) %5Effort(Time){:} %6CLOCKSUM{Total}

#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[top=2.1cm,bottom=2.1cm,left=2.1cm,right=2.1cm]{geometry}
#+LaTeX_HEADER: \setmainfont[Mapping=tex-text]{Times New Roman}
#+LaTeX_HEADER: \setsansfont[Mapping=tex-text]{Tahoma}
#+LaTeX_HEADER: \setmonofont{Courier New}
#+LaTeX_HEADER: \setCJKmainfont[BoldFont={Adobe Heiti Std},ItalicFont={Adobe Kaiti Std}]{Adobe Song Std}
#+LaTeX_HEADER: \setCJKsansfont{Adobe Heiti Std}
#+LaTeX_HEADER: \setCJKmonofont{Adobe Fangsong Std}
#+LaTeX_HEADER: \punctstyle{hangmobanjiao}
#+LaTeX_HEADER: \usepackage{color,graphicx}
#+LaTeX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{colortbl}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage[bf,small,indentafter,pagestyles]{titlesec}

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style2.css" />

#+OPTIONS: ^:nil
#+OPTIONS: tex:t

* 中小企业架构
  该架构中使用了Nginx作为前端的负载均衡器，使用KeepAlived作为Nginx负载
  均衡的高可用。
** 项目架构拓扑图
** 项目环境一览
   | 主机名               | eth0(外网)          |     eth1(内网) | 说明                       |
   |----------------------+---------------------+----------------+----------------------------|
   | lb01.lavenliu.com    | 192.168.19.150      | 192.168.20.150 | Nginx负载均衡（主）        |
   |----------------------+---------------------+----------------+----------------------------|
   | lb02.lavenliu.com    | 192.168.19.151      | 192.168.20.151 | Nginx负载均衡（备）        |
   |----------------------+---------------------+----------------+----------------------------|
   | www.lavenliu.com     | VIP: 192.168.19.250 |              - | 对外提供服务的IP           |
   |----------------------+---------------------+----------------+----------------------------|
   | lnmp01.lavenliu.com  | -                   | 192.168.20.152 | WEB01服务器                |
   |----------------------+---------------------+----------------+----------------------------|
   | lamp02.lavenliu.com  | -                   | 192.168.20.153 | WEB02服务器                |
   |----------------------+---------------------+----------------+----------------------------|
   | mysql01.lavenliu.com | -                   | 192.168.20.158 | MySQL服务器（主）          |
   |----------------------+---------------------+----------------+----------------------------|
   | mysql02.lavenliu.com | -                   | 192.168.20.159 | MySQL服务器（从）          |
   |----------------------+---------------------+----------------+----------------------------|
   | nfs01.lavenliu.com   | -                   | 192.168.20.156 | NFS共享服务器（主）        |
   |----------------------+---------------------+----------------+----------------------------|
   | nfs02.lavenliu.com   | -                   | 192.168.20.157 | NFS共享服务器（备）        |
   |----------------------+---------------------+----------------+----------------------------|
   | rsync01.lavenliu.com | -                   | 192.168.20.160 | RSYNC备份服务器，内网yum源 |
** 公共配置
   在所有的机器上进行配置。
*** vim编辑器配置文件
	在每台机器上都要设置，
	#+BEGIN_SRC sh
cat ~/.vimrc <<EOF
set nocompatible
filetype indent on
filetype plugin on
set tabstop=4
set shiftwidth=4
set autoindent
set cindent
set smartindent
set hlsearch
syntax enable
set dict=/usr/share/dict/words
if has('statusline')
    set laststatus=2
    "Broken down into easily includeable segments
    set statusline=%<%f\ " Filename
    set statusline+=%w%h%m%r " Options
    set statusline+=\ [%{&ff}/%Y] " filetype
    "ASCII/Hexadecimal value of under current cursor
    set statusline+=\ [ASCII=\%03.3b/HEX=\%02.2B]
    "Right aligned file nav info
    set statusline+=%=%-14.(%l,%c%V%)\ %p%%
endif
EOF
echo "alias vi='vim'" >> ~/.bashrc
. ~/.bashrc
	#+END_SRC
*** 删除不必要的用户和组
	Linux提供了各种不同角色的系统账号，在系统安装完毕，默认会生成很多不
	必要的用户和用户组。项目上不需要这些用户和组，应立即删除他们，因为
	账户越多，系统就越不安全，从而很可能被黑客利用，危害系统的安全。

	系统中可以删除的用户和组大致如下：
	1. 可删除的用户：如adm、lp、shutdown、halt、news、uucp、operator、games、gopher等；
	2. 可删除的用户组：如adm、lp、news、uucp、games、dip、pppusers、popusers、slipusers等。

    下面以删除games用户和组为例，操作如下：
	#+BEGIN_SRC sh
userdel games
groupdel games
	#+END_SRC

	有些时候，某些用户仅仅用作进程调用或者用户组调用，并不需要登录功能，
	在创建用户时，可以禁止用户登录，如要禁止nginx用户登录功能，可以执行
	如下操作：
	#+BEGIN_SRC sh
useradd -s /sbin/nologin -M nginx
	#+END_SRC
*** 禁用不需要的开机启动项
	我们应该遵守这样一个原则：最小化原则。就是尽量不安装不使用的软件，
	尽量不开启不需要的服务。即只要不用的服务就不需要开启，这样系统的性
	能和安全性才是最好的。
	#+BEGIN_SRC sh
chkconfig --list |grep 3:on |egrep -v "sshd|rsyslog|crond|network" |awk '{ print $1 }' |sed -r 's#(.*)#chkconfig \1 off#g'
	#+END_SRC
*** 删除系统登录欢迎信息
	登录系统时，系统会默认打印操作系统名称及内核版本号到屏幕上，方便了
	系统管理人员，但同时这些信息有时候可能被黑客利用，从而成为攻击服务
	器的帮凶，为了保证系统的安全，可以修改或删除这些相关的系统文件，这
	些文件有如下4个，分别为/etc/issue、/etc/issue.net、
	/etc/redhat-release和/etc/motd，可以把里面的内容清空，
	#+BEGIN_SRC sh
> /etc/issue
> /etc/issue.net
> /etc/redhat-release
> /etc/motd
	#+END_SRC
*** hosts文件
	所有主机均使用/etc/hosts文件进行解析，程序里均使用主机名来代替IP地
	址。这样做的好处是，当服务器宕机后，只需要修改对应主机名的IP即可，
	无需修改程序里做修改。
	#+BEGIN_SRC sh
cat > /etc/hosts <<EOF
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6
192.168.20.150 lb01.lavenliu.com
192.168.20.151 lb02.lavenliu.com
192.168.20.152 lnmp01.lavenliu.com
192.168.20.156 nfs01.lavenliu.com
192.168.20.158 mysql01.lavenliu.com
192.168.20.160 rsync01.lavenliu.com
EOF
	#+END_SRC
*** RSYNC客户端设置
	客户端只需要简单的设置即可。
	#+BEGIN_SRC sh
cat > /server/scripts/setup_rsync_client.sh <<EOF
#!/usr/bin/env bash

echo "lavenliu" > /etc/rsync.password
chmod 600 /etc/rsync.password
EOF
	#+END_SRC
*** 更新YUM源
	替换系统自带的YUM源，使用阿里的YUM源，安装软件时，速度稍快。
	#+BEGIN_SRC sh
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo
yum makecache
	#+END_SRC
*** 内网YUM源配置
	本架构中的内网机器使用的是rsync01.lavenliu.com这台机器上的yum源。
	这样在安装软件包时不会占用网站带宽。
	#+BEGIN_SRC sh
cat > /etc/yum.repos.d/lan.repo <<EOF

EOF
	#+END_SRC
*** 上述步骤一键设置脚本
** 所需软件一览
   | 软件名        |   版本 | 安装方式       | 用途                                       |
   |---------------+--------+----------------+--------------------------------------------|
   | Nginx         |  1.6.3 | 源码编译安装   | 前端负载均衡；后端WEB                      |
   |---------------+--------+----------------+--------------------------------------------|
   | KeepAlived    | 1.2.15 | yum方式安装    | 作为前端Nginx高可用                        |
   |---------------+--------+----------------+--------------------------------------------|
   | MySQL         | 5.5.32 | 二进制方式安装 | 供WEB服务器存储数据                        |
   |---------------+--------+----------------+--------------------------------------------|
   | Php           | 5.3.27 | 源码编译安装   | 作为WEB的动态程序                          |
   |---------------+--------+----------------+--------------------------------------------|
   | rsync         |  3.0.6 | 系统自带       | 供内网备份使用                             |
   |---------------+--------+----------------+--------------------------------------------|
   | inotify-tools |   3.14 | yum方式安装    | 同步NFS服务器上有变化的文件到rsync服务器上 |
** 软件安装规划
   | 主机名               | 安装软件                 | 说明                                           |
   |----------------------+--------------------------+------------------------------------------------|
   | lb01.lavenliu.com    | Nginx，KeepAlived        | Nginx负载均衡（主）                            |
   |----------------------+--------------------------+------------------------------------------------|
   | lb02.lavenliu.com    | Nginx，KeepAlived        | Nginx负载均衡（备）                            |
   |----------------------+--------------------------+------------------------------------------------|
   | lnmp01.lavenliu.com  | Nginx，MySQL，PHP        | WEB01服务器                                    |
   |----------------------+--------------------------+------------------------------------------------|
   | lamp02.lavenliu.com  | Apache，MySQL，PHP       | WEB02服务器                                    |
   |----------------------+--------------------------+------------------------------------------------|
   | mysql01.lavenliu.com | MySQL                    | MySQL服务器（主）                              |
   |----------------------+--------------------------+------------------------------------------------|
   | mysql02.lavenliu.com | MySQL                    | MySQL服务器（从）                              |
   |----------------------+--------------------------+------------------------------------------------|
   | nfs01.lavenliu.com   | nfs-utils，inotify-tools | NFS共享服务器，存放WEB上的图片和用户上传的附件 |
   |----------------------+--------------------------+------------------------------------------------|
   | nfs02.lavenliu.com   | nfs-utils，inotify-tools | NFS共享服务器，存放WEB上的图片和用户上传的附件 |
   |----------------------+--------------------------+------------------------------------------------|
   | rsync01.lavenliu.com | rsync                    | 内网备份服务器，文件分发服务器，管理端         |
  
** 数据存放位置规划
   | 目录名称        | 说明                                               |
   |-----------------+----------------------------------------------------|
   | /server/scripts | 脚本存放处                                         |
   |-----------------+----------------------------------------------------|
   | /server/tools   | 所有软件的源码存放目录                             |
   |-----------------+----------------------------------------------------|
   | /application    | 所有服务的安装目录                                 |
   |-----------------+----------------------------------------------------|
   | /backup         | 定时备份文件的存放目录，用来做备份服务器的主要目录 |
   |-----------------+----------------------------------------------------|
   | /lanrepo        | 仅存在于分发服务器，用来做内网yum源                |
   |-----------------+----------------------------------------------------|
   | /data           | 仅存在于NFS和备份服务器，用来做挂载点目录          |
   |-----------------+----------------------------------------------------|
   | /data0          | 仅存在于提供WEB服务主机上，用来做WEB虚拟主机用     |
** 开始安装部署
   本次安装部署的顺序是从架构图的后端往前部署，这些后端的服务是WEB服务
   的所依赖的，所以，从后往前部署的好处是，当部署前端的WEB服务时，不需
   要再回过头处理后端的服务了。

   安装顺序图
*** SSH无密码登录设置
	这里的rsync01.lavenliu.com作为内网机器的管理端，从该机以lavenliu用
	户身份远程ssh访问其他内网机器均不需要密码。

	首先，需要设置除管理端机器的所有机器IP地址，IP地址规划参考项目环境
	的规划。
	#+BEGIN_SRC sh
ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.20.150
ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.20.151
ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.20.152
ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.20.156
ssh-copy-id -i ~/.ssh/id_dsa.pub root@192.168.20.158
	#+END_SRC
*** 部署RSYNC备份服务
**** rsync服务端配置文件
	 #+BEGIN_SRC sh
cat > /etc/rsyncd.conf << EOF
# rsync server
# created by lavenliu
uid = rsync
gid = rsync
use chroot = no
max connections = 2000
timeout = 600
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsyncd.lock
log file = /var/log/rsyncd.log
ignore errors
read only = false
list = false
hosts allow = 192.168.20.0/24
hosts deny = 0.0.0.0/32
auth users = rsync_backup
secrets file = /etc/rsync.password

#########################################
[backup]
comment = backup by lavenliu 2016-03-06
path = /backup

[bbs]
comment = bbs by lavenliu 2016-03-06
path = /data0/www/bbs

[blog]
comment = blog by lavenliu 2016-03-06
path = /data0/www/blog
EOF
	 #+END_SRC
**** 设置rsync密码文件及其权限
	 #+BEGIN_SRC sh
useradd rsync -s /sbin/nologin -M
echo "lavenliu" > /etc/rsync.password
chmod 600 /etc/rsync.password
mkdir /backup
chown -R rsync /backup
echo "rsync_backup:lavenliu" > /etc/rsync.password
chmod 600 /etc/rsync.password
	 #+END_SRC
**** 以守护进程方式启动rsync
	 #+BEGIN_SRC sh
rsync --daemon
	 #+END_SRC
**** 设置rsync开机启动
	 #+BEGIN_SRC sh
echo "rsync --daemon" >> /etc/rc.local
cat /etc/rc.local
	 #+END_SRC
**** 一键设置脚本
	 #+BEGIN_SRC sh
#!/usr/bin/env bash

# 生成rsync服务配置文件
cat > /etc/rsyncd.conf <<EOF
# rsync server
# created by lavenliu
uid = rsync
gid = rsync
use chroot = no
max connections = 2000
timeout = 600
pid file = /var/run/rsyncd.pid
lock file = /var/run/rsyncd.lock
log file = /var/log/rsyncd.log
ignore errors
read only = false
list = false
hosts allow = 192.168.56.0/24
hosts deny = 0.0.0.0/32
auth users = rsync_backup
secrets file = /etc/rsync.password

#########################################
[backup]
comment = backup by lavenliu 2016-03-06
path = /backup

[bbs]
comment = bbs by lavenliu 2016-03-06
path = /data0/www/bbs

[blog]
comment = blog by lavenliu 2016-03-06
path = /data0/www/blog
EOF

# 创建共享目录
mkdir /backup
mkdir -p /data0/www/{bbs,blog}

# 创建rsync密码文件并设置权限
useradd rsync -s /sbin/nologin -M
chown -R rsync /backup
echo "rsync_backup:lavenliu" > /etc/rsync.password
chmod 600 /etc/rsync.password

echo "rsync --daemon" >> /etc/rc.local

# 启动rsync服务
rsync --daemon
if [ $? -eq 0 ]; then
    echo -e "\033[34mrsync service is running successfully\033[0m"
else
    echo -e "\033[31mrsync service is not running, please check...\033[0m"
fi
	 #+END_SRC
*** 部署NFS文件共享服务
**** 共享目录规划
	 数据存放在目录/data目录下，www业务的数据存放在/data/www目录下，
	 bbs业务的数据存放在/data/bbs目录下，blog业务的数据存放在
	 /data/blog目录下。
	 #+BEGIN_SRC sh
mkdir -p /data/{www,bbs,blog}
	 #+END_SRC
**** 配置NFS
	 #+BEGIN_SRC sh
cat > /etc/exports << EOF
/data 192.168.20.0/24(rw,sync,all_squash)
EOF
	 #+END_SRC
**** 共享目录权限设置
	 #+BEGIN_SRC sh
chown -R nfsnobody.nfsnobody /data
	 #+END_SRC
**** 启动NFS服务
	 #+BEGIN_SRC sh
/etc/init.d/rpcbind restart
/etc/init.d/nfs restart
	 #+END_SRC
**** 设置NFS开启启动
	 #+BEGIN_SRC sh
echo "/etc/init.d/rpcbind start" >> /etc/rc.local
echo "/etc/init.d/nfs start" >> /etc/rc.local
	 #+END_SRC
*** 部署MySQL数据库服务（主）
	由于编译安装PHP时，需要依赖MySQL的一些库文件，所以在lamp01及lnmp01
	上也安装MySQL，但是安装完毕，不启动MySQL即可。而mysql01及mysql02是
	专门的数据库服务器，所以安装完毕要启动MySQL服务。
**** 一键安装MySQL
	 #+BEGIN_SRC sh
cat > /server/scripts/install_mysql.sh <<EOF
#!/bin/bash

# 加载functions文件
. /etc/init.d/functions

YUM=/usr/bin/yum
WGET=/usr/bin/wget
TAR=/bin/tar
TOOLS_DIR=/home/lavenliu/tools

# 设置日志文件及路径
LOG_FILE=/tmp/lnmp.log
if [ -f $LOG_FILE ] ; then
	> $LOG_FILE
fi

# following steps for MySQL
useradd mysql -s /sbin/nologin -M
cd /home/lavenliu/tools && tar -xf mysql-5.5.32-linux2.6-x86_64.tar.gz
mv /home/lavenliu/tools/mysql-5.5.32-linux2.6-x86_64 /application/mysql-5.5.32
ln -s /application/mysql-5.5.32 /application/mysql
/application/mysql/scripts/mysql_install_db \
--basedir=/application/mysql \
--datadir=/application/mysql/data \
--user=mysql

ln -s /application/mysql-5.5.32 /application/mysql
chown -R mysql.mysql /application/mysql/
EOF
	 #+END_SRC
**** MySQL配置文件
	 #+BEGIN_SRC sh
/bin/cp /application/mysql/support-files/my-small.cnf /etc/my.cnf
	 #+END_SRC
**** 启动MySQL
	 #+BEGIN_SRC sh
/bin/cp /application/mysql/support-files/mysql.server /etc/init.d/mysqld
chmod 755 /etc/init.d/mysqld
sed -i 's#/usr/local/mysql#/application/mysql#g' /etc/init.d/mysqld
/etc/init.d/mysqld start
chkconfig mysqld on
	 #+END_SRC
**** 设置环境变量
	 设置环境变量，以便可以使用mysql客户端工具，
	 #+BEGIN_SRC sh
echo "PATH=$PATH:/application/mysql/bin" >> ~/.bashrc
echo "export PATH" >> ~/.bashrc
. ~/.bashrc
	 #+END_SRC
**** 更改MySQL密码
	 新安装的MySQL是没有密码的，所以接下来设置MySQL数据库密码，
	 #+BEGIN_SRC sh
mysqladmin -uroot password "123456" # 设置新密码，建议设置复杂度较高的密码
mysqladmin -uroot -p123456 password "lavenliu" # 修改密码
	 #+END_SRC
**** 删除MySQL多余的默认用户
	 #+BEGIN_SRC sh
mysql -uroot -p
Enter password: 
mysql> drop database test;
mysql> select user,host from mysql.user;
+------+-----------+
| user | host      |
+------+-----------+
| root | 127.0.0.1 |
| root | ::1       | # 把此用户删除
|      | lnmp01    | # 把此用户删除
| root | lnmp01    | # 把此用户删除
|      | localhost | # 把此用户删除
| root | localhost |
+------+-----------+
6 rows in set (0.00 sec)
mysql> drop user ''@'localhost';
mysql> drop user ''@'lnmp01';
mysql> drop user 'root'@'::1';
mysql> drop user 'root'@'127.0.0.1';
mysql> drop user 'root'@'lnmp01';
	 #+END_SRC
**** 为客户端访问数据库授权
	 #+BEGIN_SRC sh
mysql> create database bbs;
mysql> create database cms;
mysql> create database wordpress;
mysql> grant all on *.* to 'root'@'localhost' identified by '123456' with grant option;
mysql> grant select, insert, update, delete on bbs.* to bbs@'192.168.20.%' identified by '123456';
mysql> grant select, insert, update, delete on cms.* to cms@'192.168.20.%' identified by '123456';
mysql> grant select, insert, update, delete on wordpress.* to wordpress@'192.168.20.%' identified by '123456';
mysql> flush privileges;
	 #+END_SRC
*** 部署MySQL数据库服务（备）
	MySQL的安装与主库的安装方式相同。
**** 主库MySQL同步设置
**** 从库MySQL同步设置
*** 部署WEB服务
**** 一键安装Nginx
	 #+BEGIN_SRC sh
cat > /server/scripts/install_nginx.sh <<EOF
#!/bin/bash

# 加载functions文件
. /etc/init.d/functions

YUM=/usr/bin/yum
WGET=/usr/bin/wget
TAR=/bin/tar
TOOLS_DIR=/home/lavenliu/tools

# 设置日志文件及路径
LOG_FILE=/tmp/lnmp.log
if [ -f $LOG_FILE ] ; then
	> $LOG_FILE
fi

# following steps for Linux
## check nginx related
echo "Check Gnu/Linux Environment ..."
echo "To install Nginx, the linux box should pre-install:"
echo -e "\t1. openssl-devel"
echo -e "\t2. pcre-devel-devel"
echo -e "\t3. need nginx user or other"
echo "Now, beginning check the requirement"
rpm -q openssl-devel
if [ $? -eq 1 ] ; then
	echo "openssl-devel not installed"
	echo "install openssl-devel now..."
	$YUM install -y openssl-devel 
	if [ $? -eq 0 ]; then
		echo "openssl-devel installed successfully"
	else
		echo "openssl-devel installed failed"
	fi    
fi

rpm -q pcre-devel
if [ $? -eq 1 ] ; then
	echo "pcre-devel not installed"
	echo "install pcre-devel now..."
	$YUM install -y pcre-devel 
	if [ $? -eq 0 ]; then
		echo "pcre-devel installed successfully"
	else
		echo "pcre-devel installed failed"
	fi
fi

id nginx &> /dev/null
if [ $? -ne 0 ]; then
	echo "nginx user is not exists"
	echo "add nginx user now..."
	useradd nginx -s /sbin/nologin -M
fi

# following steps for Nginx
[ ! -d ${TOOLS_DIR} ] && mkdir -p /home/lavenliu/tools
cd /home/lavenliu/tools/
$WGET http://nginx.org/download/nginx-1.6.3.tar.gz
$TAR -xf nginx-1.6.3.tar.gz
cd nginx-1.6.3
./configure --user=nginx --group=nginx --prefix=/application/nginx-1.6.3 \
--with-http_ssl_module \
--with-http_stub_status_module 
if [ $? -ne 0 ] ; then
	echo "configure failed"
	exit 1
fi

make && make install
if [ $? -ne 0 ] ; then
	echo "make failed"
	exit 1
fi

ln -s /application/nginx-1.6.3 /application/nginx
EOF
	 #+END_SRC
**** Nginx作为WEB服务器的配置文件
	 #+BEGIN_SRC sh
cat > /application/nginx/conf/nginx.conf << EOF
worker_processes  1;

error_log logs/error.log error;

events {
    worker_connections  1024;
}

http {
    include            mime.types;
    default_type       application/octet-stream;
    sendfile           on;
    keepalive_timeout  65;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
			          '"$http_user_agent" "$http_x_forwarded_for"';

    include extra/*.conf;
}
EOF
	 #+END_SRC

	 www虚拟主机配置文件，
	 #+BEGIN_SRC sh
cat > /application/nginx/conf/extra/www.conf << EOF
server {
    listen       80;
    server_name  lavenliu.com;
    rewrite ^/(.*) http://www.lavenliu.com/$1 permanent;
}

server {
    listen       80;
    server_name  www.lavenliu.com;
    
    location / {
        root   /data/www/www;
        index  index.html index.htm;
    }
    access_log logs/access_www.log main;
}
EOF
	 #+END_SRC

	 bbs虚拟主机配置文件，
	 #+BEGIN_SRC sh
cat > /application/nginx/conf/extra/bbs.conf << EOF
server {               # 第一个server标签，表示一个独立的虚拟主机站点
    listen       80;   # 提供服务外的端口，默认80
    server_name  bbs.lavenliu.com; # 提供服务的域名，主机名
    
    location / { # 第一个location标签开始
        root   /data/www/bbs; # 站点的根目录，相当于Nginx安装目录
        index  index.php index.html index.htm; # 默认的首页文件，多个用空格分开
		rewrite ^([^\.]*)/topic-(.+)\.html$ $1/portal.php?mod=topic&topic=$2 last;
		rewrite ^([^\.]*)/article-([0-9]+)-([0-9]+)\.html$ $1/portal.php?mod=view&aid=$2&page=$3 last;
		rewrite ^([^\.]*)/forum-(\w+)-([0-9]+)\.html$ $1/forum.php?mod=forumdisplay&fid=$2&page=$3 last;
		rewrite ^([^\.]*)/thread-([0-9]+)-([0-9]+)-([0-9]+)\.html$ $1/forum.php?mod=viewthread&tid=$2&extra=page%3D$4&page=$3 last;
		rewrite ^([^\.]*)/group-([0-9]+)-([0-9]+)\.html$ $1/forum.php?mod=group&fid=$2&page=$3 last;
		rewrite ^([^\.]*)/space-(username|uid)-(.+)\.html$ $1/home.php?mod=space&$2=$3 last;
		rewrite ^([^\.]*)/blog-([0-9]+)-([0-9]+)\.html$ $1/home.php?mod=space&uid=$2&do=blog&id=$3 last;
		rewrite ^([^\.]*)/(fid|tid)-([0-9]+)\.html$ $1/index.php?action=$2&value=$3 last;
		rewrite ^([^\.]*)/([a-z]+[a-z0-9_]*)-([a-z0-9_\-]+)\.html$ $1/plugin.php?id=$2:$3 last;
		if (!-e $request_filename) {
				return 404;
		}
    }
    location ~ .*\.(php|php5)?$ {
        # 注意这里的站点根目录问题，不然会产生404的错误，
        # 这里与blog公用一个站点目录，html/blog
        root   /data/www/bbs; # 站点的根目录，相当于Nginx安装目录
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        include fastcgi.conf;
    }
	access_log logs/access_blog.log main;
}
EOF
	 #+END_SRC

	 blog虚拟主机配置文件，
	 #+BEGIN_SRC sh
cat > /application/nginx/conf/extra/blog.conf << EOF
server {               # 第一个server标签，表示一个独立的虚拟主机站点
    listen       80;   # 提供服务外的端口，默认80
    server_name  blog.lavenliu.com; # 提供服务的域名，主机名
    root         /data/www/blog; # 站点的根目录，相当于Nginx安装目录
    index  index.php index.html index.htm; # 默认的首页文件，多个用空格分开

    location / { # 第一个location标签开始
        if (-f $request_filename/index.html){
            rewrite (.*) $1/index.html break;
        }
        if (-f $request_filename/index.php){
            rewrite (.*) $1/index.php;
        }
        if (!-f $request_filename){
            rewrite (.*) /index.php;
        }
    }

    location ~ .*\.(php|php5)?$ {
        # 注意这里的站点根目录问题，不然会产生404的错误，
        # 这里与blog公用一个站点目录，html/blog
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        include fastcgi.conf;
    }
	
    access_log logs/access_blog.log main;
}
EOF
	 #+END_SRC
**** 启动Nginx
	 #+BEGIN_SRC sh
/application/nginx/sbin/nginx -t
/application/nginx/sbin/nginx
	 #+END_SRC
**** 设置Nginx开机启动
	 #+BEGIN_SRC sh
echo "/application/nginx/sbin/nginx" >> /etc/rc.local
	 #+END_SRC
*** 部署PHP服务
**** 一键安装PHP
	 #+BEGIN_SRC sh
cat > /server/scripts/install_php.sh <<EOF
#!/usr/bin/env bash

# following steps for PHP
yum install -y libpng-devel libjpeg-devel libtiff-devel libxml2-devel
yum install -y freetype-devel gd-devel curl-devel
yum install -y libmcrypt-devel mhash-devel mhash libxslt-devel libtool-ltdl-devel

cd /home/lavenliu/tools
tar -xf libiconv-1.14.tar.gz
cd libiconv-1.14
./configure --prefix=/usr/local/libiconv
make
make install

cd /home/lavenliu/tools && tar -xf php-5.3.27.tar.gz
cd php-5.3.27
./configure --prefix=/application/php-5.3.27 \
--with-mysql=/application/mysql \
--with-iconv-dir=/usr/local/libiconv \
--with-freetype-dir \
--with-jpeg-dir \
--with-png-dir \
--with-zlib \
--with-libxml-dir=/usr \
--enable-xml \
--disable-rpath \
--enable-safe-mode \
--enable-bcmath \
--enable-shmop \
--enable-sysvsem \
--enable-inline-optimization \
--with-curl \
--with-curlwrappers \
--enable-mbregex \
--enable-fpm \
--enable-mbstring \
--with-mcrypt \
--with-gd \
--enable-gd-native-ttf \
--with-openssl \
--with-mhash \
--enable-pcntl \
--enable-sockets \
--with-xmlrpc \
--enable-zip \
--enable-soap \
--enable-short-tags \
--enable-zend-multibyte \
--enable-static \
--with-xsl \
--with-fpm-user=nginx \
--with-fpm-group=nginx \
--enable-ftp
make
if [ ! -e ext/phar/phar.phar ] ; then
    touch ext/phar/phar.phar
fi
make install
ln -s /application/php-5.3.27 /application/php
EOF
	 #+END_SRC
**** PHP配置文件
	 #+BEGIN_SRC sh
cd /home/lavenliu/tools/php-5.3.27
cp php.ini-production /application/php/lib/php.ini
cp /application/php/etc/php-fpm.conf.default /application/php/etc/php-fpm.conf
	 #+END_SRC

	 设置/application/php/etc/php-fpm.conf配置文件，
	 #+BEGIN_SRC sh
cat > /application/php/etc/php-fpm.conf <<EOF
[global]
pid = run/php-fpm.pid
error_log = log/php-fpm.log
log_level = error
 
rlimit_files = 32768
 
events.mechanism = epoll
[www]
user = nginx
group = nginx
listen = 127.0.0.1:9000
 
pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
 
pm.max_requests = 2048
 
slowlog = log/$pool.log.slow
EOF
	 #+END_SRC
**** 启动PHP
	 #+BEGIN_SRC sh
/application/php/sbin/php-fpm
	 #+END_SRC
**** 设置PHP开机启动
	 #+BEGIN_SRC sh
echo "/application/php/sbin/php-fpm" >> /etc/rc.local
	 #+END_SRC
*** 部署Nginx负载均衡服务
**** 一键安装Nginx
	 参考前面的Nginx安装脚本。略
**** Nginx作为负载均衡服务器的配置文件
	 #+BEGIN_SRC sh
worker_processes  1;
events {
    worker_connections  1024;
}
http {
    include            mime.types;
    default_type       application/octet-stream;
    sendfile           on;
    keepalive_timeout  65;

	upstream web_pool {
		ip_hash;
		server 192.168.20.152:80 weight=5;
		server 192.168.20.153:80 weight=5;
	}
    
    server {
        listen       80;
        server_name  www.lavenliu.com;
        
        location / {
			proxy_pass http://web_pool;

			#proxy_redirect off;
			proxy_set_header Host $host;
			proxy_set_header X-Forwarded-For $remote_addr;
			proxy_connect_timeout 90;
			proxy_send_timeout 90;
			proxy_read_timeout 90;
			proxy_buffer_size 4k;
			proxy_buffers 4 32k;
			proxy_busy_buffers_size 64k;
			proxy_temp_file_write_size 64k;
        }
        
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
	 #+END_SRC
**** 启动Nginx
	 #+BEGIN_SRC sh
/application/nginx/sbin/nginx -t
/application/nginx/sbin/nginx 
	 #+END_SRC
**** 设置Nginx开机启动
	 #+BEGIN_SRC sh
echo "/application/nginx/sbin/nginx" >> /etc/rc.local
	 #+END_SRC
*** 部署KeepAlived高可用服务
**** 一键安装KeepAlived
	 这里使用了yum的方式进行安装。
	 #+BEGIN_SRC sh
yum install -y keepalived
	 #+END_SRC
**** KeepAlived配置文件（主）
	 #+BEGIN_SRC sh
cat > /etc/keepalived/keepalived.conf <<EOF
global_defs {
   notification_email {
       ldc@163.com
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

vrrp_instance VI_1 {
    state MASTER
    interface eth1
    virtual_router_id 51
    priority 150
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.20.250/24
    }
}
EOF
	 #+END_SRC
**** KeepAlived配置文件（备）
	 #+BEGIN_SRC sh
cat > /etc/keepalived/keepalived.conf <<EOF
global_defs {
   notification_email {
       ldc@163.com
   }
   notification_email_from Alexandre.Cassen@firewall.loc
   smtp_server 192.168.200.1
   smtp_connect_timeout 30
   router_id LVS_DEVEL
}

vrrp_instance VI_1 {
    state BACKUP # 这里做了修改
    interface eth1
    virtual_router_id 51
    priority 100 # 这里做了修改
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
        192.168.20.250/24
    }
}
EOF
	 #+END_SRC
** 测试整个架构
   测试的目的是让每个点都不存在单点故障。
*** 内网机器备份文件到RSYNC服务器
*** 一台Nginx负载均衡出现故障是否影响对外提供服务
*** 一台WEB宕机是否影响对外提供服务
*** MySQL主库宕机是否影响业务
*** NFS宕机是否影响业务
** 后续维护
*** 用户权限集中管理
*** 用户行为日志审计管理
** 附录
*** 安装Nginx脚本
*** 安装MySQL脚本
*** 安装PHP脚本
** Misc
   #+BEGIN_SRC sh
yum --enablerepo=lanrepo --disablerepo=base,extras,updates,epel install telnet
wget http://192.168.20.160/tools/
wget http://192.168.20.160/conf/
   #+END_SRC
* Architectural Requirements
  1. Easy to separate   -> Autonomy
  2. Easy to understand -> Understandability
  3. Easy to extend     -> Extensibility
  4. Easy to change     -> Changeability
  5. Easy to replace    -> Replaceability
  6. Easy to deploy     -> Deployability
  7. Easy to scale      -> Scalability
  8. Easy to recover    -> Resilience
  9. Easy to connect    -> Uniform interface
  10. Easy to afford    -> Cost-efficiency
* SaltStack环境配置
  一个拓扑图。file:///.images/saltstack-arch.png

  
  1. 系统初始化
	 1. DNS解析
	 2. 内核参数优化
  2. Haproxy服务
  3. Nginx+PHP
  4. Memcached
  5. MySQL

  实现两台机器进行实验，
  
** base环境配置
  salt的设置，所有机器都使用到都放在base环境下，测试环境的放在test环境
  下，生产环境的放在prod环境下，
  #+BEGIN_SRC sh
file_roots:
  base:
    - /srv/salt/base
  test:
    - /srv/salt/test
  prod:
    - /srv/salt/prod
  #+END_SRC

  pillar相关的设置，
  #+BEGIN_SRC sh
pillar_roots:
  base:
    - /srv/pillar/base
  test:
    - /srv/pillar/test
  prod:
    - /srv/pillar/prod
  #+END_SRC

  准备prod.zip，解压并放到/srv/salt/prod目录下，

  运维不做标准化，很难做自动化。

  #+BEGIN_SRC sh
cd /srv/salt/base
mkdir -p init/files
cd init
# 
# 设置DNS
vi dns.sls
/etc/resolv.conf;
  file.managed:
    - source: salt://init/files/resolv.conf
    - user: root
    - group: root
    - mode: 644
#
# 设置history
vi history.sls
/etc/profile:
  file.append:
    - text:
      - export HISTTIMEFORMAT="%F %T `whoami` "
#
# 记录命令操作（审计功能）
vi audit.sls
/etc/bashrc:
  file.append:
    - text:
      - export PROMPT_COMMAND='{ msg=$(history 1 | { read x y; echo $y; });logger "[euid=$(whoami)]":$(who am i):[`pwd`]"$msg"; }'
#
# vim sysctl.sls
net.ipv4.ip_local_port_range:
  sysctl.present:
    - value: 10000 65000
fs.file-max:
  sysctl.present:
    - value: 65000
net.ipv4.ip_forward:
  sysctl.present:
    - value: 1
  #+END_SRC

  接下来创建一个sls文件，来include上面的sls文件，
  #+BEGIN_SRC sh
vim env_init.sls
include:
  - init.dns
  - init.history
  - init.audit
  - init.sysctl
  #+END_SRC

  接下来就可以在top.sls文件中直接引用env_init.sls了，
  #+BEGIN_SRC sh
base:
  '*':
  - init.env_init
  #+END_SRC
** prod环境配置
*** pkg模块
   #+BEGIN_SRC sh
cd /srv/salt/prod
ll
cluster/
haproxy/
keepalived/
libevent/
memcached/
nginx/
pcre/
php/
pkg/
user/
web/
   #+END_SRC

   接着从pkg模块入手，因为有的软件是编译安装的，因此从此文件开始，
   #+BEGIN_SRC sh
pkg-init:
  pkg.installed:
    - names:
      - gcc
      - gcc-c++
      - glibc
      - make
      - autoconf
      - openssl
      - openssl-devel
   #+END_SRC
*** haproxy
   接着从haproxy入手，
   #+BEGIN_SRC sh
cd haproxy
ls
files install.sls
# 
cat install.sls
include:
  - pkg.pkg-init

haproxy-install:
  file.managed:
    - name: /usr/local/src/haproxy-1.5.3.tar.gz
    - source: salt://haproxy/files/haproxy-1.5.3.tar.gz
    - mode: 755
    - user: root
    - group: root
  cmd.run:
    - name: cd /usr/local/src && tar zxf haproxy-1.5.3.tar.gz && cd haproxy-1.5.3 && make TARGET=linux26 PREFIX=/usr/local/haproxy && make install PREFIX=/usr/local/haproxy
    - unless: test -d /usr/local/haproxy
    - require:
      - pkg: pkg-init
      - file: haproxy-install

/etc/init.d/haproxy:
  file.managed:
    - source: salt://haproxy/files/haproxy.init
    - mode: 755
    - user: root
    - group: root
    - require:
      - cmd: haproxy-install

net.ipv4.ip_nonlocal_bind:
  sysctl.present:
    - value: 1

haproxy-config-dir:
  file.directory:
    - name: /etc/haproxy
    - mode: 755
    - user: root
    - group: root

haproxy-init:
  cmd.run:
    - name: chkconfig --add haproxy
    - unless: chkconfig --list | grep haproxy
    - require:
      - file: /etc/init.d/haproxy
   #+END_SRC

   看一下haproxy的启动脚本，
   #+BEGIN_SRC sh
cat /etc/init.d/haproxy
#!/bin/sh
#
# chkconfig: - 85 15
# description: HA-Proxy is a TCP/HTTP reverse proxy which is particularly suited \
#              for high availability environments.
# processname: haproxy
# config: /etc/haproxy/haproxy.cfg
# pidfile: /var/run/haproxy.pid

# Script Author: Simon Matter <simon.matter@invoca.ch>
# Version: 2004060600

# Source function library.
if [ -f /etc/init.d/functions ]; then
  . /etc/init.d/functions
elif [ -f /etc/rc.d/init.d/functions ] ; then
  . /etc/rc.d/init.d/functions
else
  exit 0
fi

# Source networking configuration.
. /etc/sysconfig/network

# Check that networking is up.
[ ${NETWORKING} = "no" ] && exit 0

# This is our service name
BASENAME=`basename $0`
if [ -L $0 ]; then
  BASENAME=`find $0 -name $BASENAME -printf %l`
  BASENAME=`basename $BASENAME`
fi

[ -f /etc/$BASENAME/$BASENAME.cfg ] || exit 1

RETVAL=0

start() {
  /usr/local/haproxy/sbin/$BASENAME -c -q -f /etc/$BASENAME/$BASENAME.cfg
  if [ $? -ne 0 ]; then
    echo "Errors found in configuration file, check it with '$BASENAME check'."
    return 1
  fi

  echo -n "Starting $BASENAME: "
  daemon /usr/local/haproxy/sbin/$BASENAME -D -f /etc/$BASENAME/$BASENAME.cfg -p /var/run/$BASENAME.pid
  RETVAL=$?
  echo
  [ $RETVAL -eq 0 ] && touch /var/lock/subsys/$BASENAME
  return $RETVAL
}

stop() {
  echo -n "Shutting down $BASENAME: "
  killproc $BASENAME -USR1
  RETVAL=$?
  echo
  [ $RETVAL -eq 0 ] && rm -f /var/lock/subsys/$BASENAME
  [ $RETVAL -eq 0 ] && rm -f /var/run/$BASENAME.pid
  return $RETVAL
}

restart() {
  /usr/local/haproxy/sbin/$BASENAME -c -q -f /etc/$BASENAME/$BASENAME.cfg
  if [ $? -ne 0 ]; then
    echo "Errors found in configuration file, check it with '$BASENAME check'."
    return 1
  fi
  stop
  start
}

reload() {
  /usr/local/haproxy/sbin/$BASENAME -c -q -f /etc/$BASENAME/$BASENAME.cfg
  if [ $? -ne 0 ]; then
    echo "Errors found in configuration file, check it with '$BASENAME check'."
    return 1
  fi
  /usr/local/haproxy/sbin/$BASENAME -D -f /etc/$BASENAME/$BASENAME.cfg -p /var/run/$BASENAME.pid -sf $(cat /var/run/$BASENAME.pid)
}

check() {
  /usr/local/haproxy/sbin/$BASENAME -c -q -V -f /etc/$BASENAME/$BASENAME.cfg
}

rhstatus() {
  status $BASENAME
}

condrestart() {
  [ -e /var/lock/subsys/$BASENAME ] && restart || :
}

# See how we were called.
case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  restart)
    restart
    ;;
  reload)
    reload
    ;;
  condrestart)
    condrestart
    ;;
  status)
    rhstatus
    ;;
  check)
    check
    ;;
  *)
    echo $"Usage: $BASENAME {start|stop|restart|reload|condrestart|status|check}"
    exit 1
esac
 
exit $?
   #+END_SRC

   haproxy的配置文件呢？在cluster模块内，
   #+BEGIN_SRC sh
cd cluster
cat haproxy-outside.sls
include:
  - haproxy.install

haproxy-service:
  file.managed:
    - name: /etc/haproxy/haproxy.cfg
    - source: salt://cluster/files/haproxy-outside.cfg
    - user: root
    - group: root
    - mode: 644
  service.running:
    - name: haproxy
    - enable: True
    - reload: True
    - require:
      - cmd: haproxy-init
    - watch:
      - file: haproxy-service
   #+END_SRC

   接下来看haproxy的配置文件，
   #+BEGIN_SRC sh
cat cluster/files/haproxy-outside.cfg
global
maxconn 100000
chroot /usr/local/haproxy
uid 99  
gid 99 
daemon
nbproc 1 
pidfile /usr/local/haproxy/logs/haproxy.pid 
log 127.0.0.1 local3 info

defaults
option http-keep-alive
maxconn 100000
mode http
timeout connect 5000ms
timeout client  50000ms
timeout server 50000ms

listen stats
mode http
bind 0.0.0.0:8888
stats enable
stats uri     /haproxy-status 
stats auth    haproxy:saltstack

frontend frontend_www_example_com
bind 192.168.56.21:80
mode http
option httplog
log global
    default_backend backend_www_example_com

backend backend_www_example_com
option forwardfor header X-REAL-IP
option httpchk HEAD / HTTP/1.0
balance source
server web-node1  192.168.56.21:8080 check inter 2000 rise 30 fall 15
server web-node2  192.168.56.22:8080 check inter 2000 rise 30 fall 15
   #+END_SRC

   在top.sls文件里进行引用，
   #+BEGIN_SRC sh
cat /srv/salt/base/top.sls

prod:
  'linux-node1.lavenliu.com':
    - cluster.haproxy-outside
   #+END_SRC

   执行前先进行测试，
   #+BEGIN_SRC sh
salt '*' state.highstate test=True
   #+END_SRC
*** keepalived
	#+BEGIN_SRC sh
cd /srv/salt/prod/keepliaved
cat install.sls
include:
  - pkg.pkg-init

keepalived-install:
  file.managed:
    - name: /usr/local/src/keepalived-1.2.17.tar.gz
    - source: salt://keepalived/files/keepalived-1.2.17.tar.gz
    - mode: 755
    - user: root
    - group: root
  cmd.run:
    - name: cd /usr/local/src && tar zxf keepalived-1.2.17.tar.gz && cd keepalived-1.2.17 && ./configure --prefix=/usr/local/keepalived --disable-fwmark && make && make install
    - unless: test -d /usr/local/keepalived
    - require:
      - file: keepalived-install

/etc/sysconfig/keepalived:
  file.managed:
    - source: salt://keepalived/files/keepalived.sysconfig
    - mode: 644
    - user: root
    - group: root

/etc/init.d/keepalived:
  file.managed:
    - source: salt://keepalived/files/keepalived.init
    - mode: 755
    - user: root
    - group: root

keepalived-init:
  cmd.run:
    - name: chkconfig --add keepalived
    - unless: chkconfig --list | grep keepalived
    - require:
      - file: /etc/init.d/keepalived

/etc/keepalived:
  file.directory:
    - user: root
    - group: root
	#+END_SRC

	接着查看/srv/salt/prod/cluster/haproxy-outside-keepalived.sls，
	#+BEGIN_SRC sh
include:
  - keepalived.install
keepalived-server:
  file.managed:
    - name: /etc/keepalived/keepalived.conf
    - source: salt://cluster/files/haproxy-outside-keepalived.conf
    - mode: 644
    - user: root
    - group: root
    - template: jinja
    {% if grains['fqdn'] == 'saltstack-node1.example.com' %}
    - ROUTEID: haproxy_ha
    - STATEID: MASTER
    - PRIORITYID: 150
    {% elif grains['fqdn'] == 'saltstack-node2.example.com' %}
    - ROUTEID: haproxy_ha
    - STATEID: BACKUP
    - PRIORITYID: 100
    {% endif %}
  service.running:
    - name: keepalived
    - enable: True
    - watch:
      - file: keepalived-server
	#+END_SRC

	接着设置KeepAlived的配置文件，
	#+BEGIN_SRC sh
cat /srv/salt/prod/cluster/files/haproxy-outside-keepalived.conf
! Configuration File for keepalived
global_defs {
   notification_email {
     saltstack@example.com
   }
   notification_email_from keepalived@example.com
   smtp_server 127.0.0.1
   smtp_connect_timeout 30
   router_id {{ROUTEID}}
}

vrrp_instance haproxy_ha {
state {{STATEID}}
interface eth0
    virtual_router_id 36
priority {{PRIORITYID}}
    advert_int 1
authentication {
auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
       192.168.56.20
    }
}
	#+END_SRC

	接着在top.sls文件中引用，
	#+BEGIN_SRC sh
prod:
  'linux-node1.lavenliu.com':
    - cluster.haproxy-outside
    - cluster.haproxy-outside-keepalived
	#+END_SRC

	接着执行state，
	#+BEGIN_SRC sh
salt '*' state.highstate test=True
	#+END_SRC
*** users
	用户提前先设置好，所有机器的UID应该都是统一的。
	#+BEGIN_SRC sh
cat /srv/salt/prod/user/www.sls
www-user-group:
  group.present:
    - name: www
    - gid: 1000

  user.present:
    - name: www
    - fullname: www
    - shell: /sbin/nologin
    - uid: 1000
    - gid: 1000
	#+END_SRC
* 如何实现自动化扩容
  这里使用Docker实现自动化扩容。

  Docker的三大功能：
  1. 构建
  2. 运输
  3. 运行

  最常用的场景：
  1. 构建
	 #+BEGIN_EXAMPLE
	 构建可以做CI/CD
	 #+END_EXAMPLE
  2. 当做轻量级的虚拟机使用
	 #+BEGIN_SRC sh
	 
	 #+END_SRC


  Docker的问题，Docker的守护进程重启，导致容器会停掉。
  

  #+BEGIN_SRC sh
docker run -it --rm --net=none centos /bin/bash
  #+END_SRC

  获取容器的PID，
  #+BEGIN_SRC sh
docker inspect -f '{.State.Pid}' <container_id>
pid=2778
sudo mkdir -p /var/run/netns
sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid
  #+END_SRC

  如何实现自动化扩容呢？
  1. 监测+触发（Zabbix监控扩容需求）
  2. 创建资源（OpenStack/Docker）
  3. 自动发现、注册（Etcd）
  4. Ext_pillar（Etcd_pillar）
  5. JinJa（自动生成配置）、服务管理（自动重载）
  6. 对外提供服务

  这里的难点在于3、4、5点。

  接下来，
  1. 如何使用Etcd，
  2. 如何使用Ext_pillar
  3. 如何自动生成配置及重载

  Etcd是一个分布式的key-value存储服务。

  支持API，

  快速

  使用Go语言编写

  在自动化扩容场景中，让Etcd做一个服务发现，把WEB节点的IP地址，端口号
  等内容写在Etcd中，Etcd的Key可以设置过期时间。

  接下来安装配置Etcd，
  #+BEGIN_SRC sh
curl -L  https://github.com/coreos/etcd/releases/download/v2.2.2/etcd-v2.2.2-linux-amd64.tar.gz -o etcd-v2.2.2-linux-amd64.tar.gz
tar xzvf etcd-v2.2.2-linux-amd64.tar.gz
cd etcd-v2.2.2-linux-amd64
cp etcd etcdctl /usr/local/bin
#
# 执行etcd
etcd -version
etcd Version: 2.2.2
Git SHA: b4bddf6
Go Version: go1.5.1
Go OS/Arch: linux/amd64
  #+END_SRC

  支持三种方式的分布式：
  1. static
  2. etcd Discovery
  3. 

  接下来启动Etcd，首先创建数据目录，在136这台机器上进行操作，
  #+BEGIN_SRC sh
mkdir -p /data/etcd
etcd --name auto_scale --data-dir /data/etcd \
--listen-peer-urls 'http://192.168.20.134:2380,http://192.168.20.135:2380,http://192.168.20.136:2380' \
--listen-client-urls 'http://192.168.20.134:2379,http://192.168.20.135:2379,http://192.168.20.136:2379' \
--advertise-client-urls 'http://192.168.20.134:2379,http://192.168.20.135:2379,http://192.168.20.136:2379' &
  #+END_SRC
  
  检查Etcd的进程及端口，
  #+BEGIN_SRC sh
ps -ef |grep etcd
[root@minion02 ~]# ps -ef |grep etcd
root       1918   1683  0 14:09 pts/2    00:00:00 \
etcd --name auto_scale --data-dir /data/etcd \
--listen-peer-urls http://192.168.20.134:2380,http://192.168.20.135:2380,http://192.168.20.136:2380 \
--listen-client-urls http://192.168.20.134:2379,http://192.168.20.135:2379,http://192.168.20.136:2379 \
--advertise-client-urls http://192.168.20.134:2379,http://192.168.20.135:2379,http://192.168.20.136:2379

netstat -natup |grep etcd
tcp        0      0 192.168.20.136:2379         0.0.0.0:*                   LISTEN      1918/etcd
tcp        0      0 192.168.20.135:2379         0.0.0.0:*                   LISTEN      1918/etcd
tcp        0      0 192.168.20.134:2379         0.0.0.0:*                   LISTEN      1918/etcd
tcp        0      0 192.168.20.136:2380         0.0.0.0:*                   LISTEN      1918/etcd
tcp        0      0 192.168.20.135:2380         0.0.0.0:*                   LISTEN      1918/etcd
tcp        0      0 192.168.20.134:2380         0.0.0.0:*                   LISTEN      1918/etcd
  #+END_SRC

  接着就可以使用curl与Etcd进行交互了，
  #+BEGIN_SRC sh
curl -sL http://192.168.20.136:2379/version | python -mjson.tool
{
    "etcdcluster": "2.2.0",
    "etcdserver": "2.2.2"
}
  #+END_SRC

  接下来给Etcd设置一个key，
  #+BEGIN_SRC sh
curl -s http://192.168.20.136:2379/v2/keys/message -XPUT -d value="hehe" | python -mjson.tool
{
    "action": "set",
    "node": {
        "createdIndex": 4,
        "key": "/message", # 不仅仅表示一个key，还可以表示一个目录
        "modifiedIndex": 4,
        "value": "hehe"
    }
}
#
#
curl -s http://192.168.20.136:2379/v2/keys/messages/key -XPUT -d value="hehe" | python -mjson.tool
{
    "action": "set",
    "node": {
        "createdIndex": 5,
        "key": "/messages/key",
        "modifiedIndex": 5,
        "value": "hehe"
    }
}
# 目录的好处
  #+END_SRC

  直接访问key，
  #+BEGIN_SRC sh
curl -s http://192.168.20.136:2379/v2/keys/messages/key | python -mjson.tool
{
    "action": "get",
    "node": {
        "createdIndex": 5,
        "key": "/messages/key",
        "modifiedIndex": 5,
        "value": "hehe"
    }
}
  #+END_SRC

  删除Key，
  #+BEGIN_SRC sh
curl -s http://192.168.20.136:2379/v2/keys/messages/key -XDELETE | python -mjson.tool
{
    "action": "delete",
    "node": {
        "createdIndex": 5,
        "key": "/messages/key",
        "modifiedIndex": 6
    },
    "prevNode": {
        "createdIndex": 5,
        "key": "/messages/key",
        "modifiedIndex": 5,
        "value": "hehe"
    }
}
# 再次访问
curl -s http://192.168.20.136:2379/v2/keys/messages/key | python -mjson.tool
{
    "cause": "/messages/key",
    "errorCode": 100,
    "index": 6,
    "message": "Key not found"
}
  #+END_SRC

  可以设置TTL，
  #+BEGIN_SRC sh
curl -s http://192.168.20.136:2379/v2/keys/key-ttl \
-XPUT \
-d value="hehe" \
-d ttl=30 | python -mjson.tool
{
    "action": "set",
    "node": {
        "createdIndex": 7,
        "expiration": "2016-07-05T06:28:37.535114513Z",
        "key": "/key-ttl",
        "modifiedIndex": 7,
        "ttl": 30,
        "value": "hehe"
    }
}
# 接着查看
curl -s http://192.168.20.136:2379/v2/keys/key-ttl | python -mjson.tool
{
    "action": "get",
    "node": {
        "createdIndex": 7,
        "expiration": "2016-07-05T06:28:37.535114513Z",
        "key": "/key-ttl",
        "modifiedIndex": 7,
        "ttl": 3, # 还剩余3秒钟
        "value": "hehe"
    }
}
# 再次查看
curl -s http://192.168.20.136:2379/v2/keys/key-ttl | python -mjson.tool
{
    "cause": "/key-ttl",
    "errorCode": 100,
    "index": 8,
    "message": "Key not found" # ttl用完就提示“Key not found”
}
  #+END_SRC

  接着让Etcd与SaltStack的pillar连接，首先确保系统上有安装python-etcd，
  #+BEGIN_SRC sh
pip install python-etcd==0.4.1
vi /etc/salt/master
ext_pillar:
  - etcd: etcd_pillar_config root=/salt/haproxy/

etcd_pillar_config:
  etcd.host: 192.168.20.134
  etcd.port: 2380
  #+END_SRC

  重启salt master，
  #+BEGIN_SRC sh
/etc/init.d/salt-master restart
salt '*' pillar.items
# 这时应该看不到pillar
  #+END_SRC

  接下来往Etcd中写入配置，
  #+BEGIN_SRC sh
curl -s http://192.168.20.134:2379/v2/keys/salt/haproxy/backend_www_lavenliu_com/web-node2 \
-XPUT -d value="192.168.20.135:8080" | python -mjson.tool
{
    "action": "set",
    "node": {
        "createdIndex": 12,
        "key": "/salt/haproxy/backend_www_lavenliu_com/web-node2",
        "modifiedIndex": 12,
        "value": "192.168.20.135:8080"
    }
}
  #+END_SRC

  使用salt进行查看，
  #+BEGIN_SRC sh
[root@master01 ~]# salt '*' pillar.items
minion02.lavenliu.com:
    ----------
    backend_www_lavenliu_com:
        ----------
        web-node2:
            192.168.20.135:8080
minion01.lavenliu.com:
    ----------
    backend_www_lavenliu_com:
        ----------
        web-node2:
            192.168.20.135:8080
  #+END_SRC

  我们已经获得了pillar，接下来就可以把这些pillar写入到haproxy配置文件
  里。
  #+BEGIN_SRC sh
cd /srv/salt/prod/cluster
# 把haproxy的配置文件设置为jinja模板，
# 修改haproxy-outside.cfg配置文件
global
maxconn 100000
chroot /usr/local/haproxy
uid 99  
gid 99 
daemon
nbproc 1 
pidfile /usr/local/haproxy/logs/haproxy.pid 
log 127.0.0.1 local3 info

defaults
option http-keep-alive
maxconn 100000
mode http
timeout connect 5000ms
timeout client  50000ms
timeout server 50000ms

listen stats
mode http
bind 0.0.0.0:8888
stats enable
stats uri     /haproxy-status 
stats auth    haproxy:saltstack

frontend frontend_www_example_com
bind 192.168.56.21:80
mode http
option httplog
log global
    default_backend backend_www_example_com

backend backend_www_example_com
option forwardfor header X-REAL-IP
option httpchk HEAD / HTTP/1.0
balance source

{% for web,web_ip in pillar.backend_www_lavenliu_com.iteritems() -%}

server {{ web }} {{ web_ip }} check inter 2000 rise 30 fall 15
{% endfor %}
  #+END_SRC

  执行salt，
  #+BEGIN_SRC sh
salt '*' state.highstate
  #+END_SRC

  查看/etc/haproxy/haproxy.cfg的内容，
  #+BEGIN_SRC sh
cat /etc/haproxy/haproxy.cfg
  #+END_SRC

  接着在etcd中添加另外一个节点，
  #+BEGIN_SRC sh
curl -s http://192.168.20.134:2379/v2/keys/salt/haproxy/backend_www_lavenliu_com/web-node3 -XPUT -d value="192.168.20.136:8080" | python -mjson.tool
  #+END_SRC

  添加完毕，执行salt状态，
  #+BEGIN_SRC sh
salt '*' state.highstate
  #+END_SRC

  接下来使用Docker来实现上述的自动化扩容，
  Zabbix触发脚本，
  #+BEGIN_SRC sh
docker pull nginx
  #+END_SRC

  编写脚本，
  #+BEGIN_SRC sh
vi auto.sh
#!/bin/bash

WEB_NODE=$1
DOCKER_IP="192.168.20.134"
DOCKER_PORT=$2
ETCD_URL="http://192.168.20.134:2379/v2/keys"
PILLAR_KEY="/salt/haproxy/backend_www_lavenliu_com"

# Create Resource
docker run -d -p $DOCKER_PORT:80 --name $WEB_NODE nginx

# Auto Register
curl -s "$ETCD_URL""$PILLAR_KEY"/"$WEB_NODE" -XPUT -d value="$DOCKER_IP:$DOCKER_PORT" | python -mjson.tool

# SaltStack
salt '*' state.highstate
  #+END_SRC

  接下来执行脚本，
  #+BEGIN_SRC sh
chmod +x auto.sh
./auto.sh web-node8 8091
  #+END_SRC

  到haproxy的监控界面进行查看。

  可以使用Python脚本改写上面的脚本，要用到Docker、Etcd及Salt的API进行调用。
** Mesos
   是一个集群资源的调度平台，也可以称为数据中心操作系统的内核。

   marathon+docker+mesos

   使用Google搜索，7个命令memos，已保存到为知笔记。

   数人科技的文档。https://www.shurenyun.com/

   
