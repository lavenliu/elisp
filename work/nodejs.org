#+TITLE: NodeJS
#+AUTHOR: LavenLiu
#+DATE: 2010-05-04
#+EMAIL: ldczz2008@163.com 

#+STARTUP: OVERVIEW
#+TAGS: OFFICE(o) HOME(h) PROJECT(p) CHANGE(c) REPORT(r) ZY(y) MYSELF(m) 
#+TAGS: PROBLEM(P) INTERRUPTTED(i) RESEARCH(R)
#+SEQ_TODO: TODO(t)  STARTED(s) WAITING(W) | DONE(d) CANCELLED(C) DEFERRED(f)
#+COLUMNS: %40ITEM(Details) %TAGS(Context) %7TODO(To Do) %5Effort(Time){:} %6CLOCKSUM{Total}

* 认识Node.js
  Node.js的诞生
  1. 2008年
  2. Ryan Dahl的目标：创建一个易扩展、适用于现代Web应用通信的服务器平台
** 国内外的应用情况
   1. LinkenIn移动版From RoR to Node.js, base on Joyent
   2. Paypay From Java to Node.js
   3. Twitter的队列：收集需要保存的Tweets，传给负责写入的进程
   4. 知乎的推送
   5. 网易
   6. 阿里
   7. 各种创业团队
** 主要应用领域
   1. RESTful API
   2. 实时通信：如消息推送等
   3. 高并发
   4. I/O阻塞
** 社区与生态圈
   社区：
   1. 生于社区
   2. 社区推进
   3. Github
   4. 国内

   生态圈：
   1. 以NPM为中心
   2. 基础服务提供商的支持
   3. 周边服务提供商的支持
** 知名度较高的Node.js开源项目
   1. express
   2. PM2
   3. iade
   4. coffeescript
   5. socket.io
   6. mongoose
   7. mocha
** IO.js
   1. Joyent的目标： 兼容性、性能
   2. 社区： New features
   3. IO.js： A friendly fork of Node.js with an open governance model
   4. 现状： IO.js的发展速度，成为了有史以来成长最快的开源项目
   5. 关系： 全面兼容，二者依然有可能合并
** Node.js与JavaScript的关系
*** JavaScript的诞生
	1. 1995年网景公司的Branden Eich，用了10天时间完成了开发
	2. JavaScript的目标： 业余人士，浏览器上的脚本语言
*** ECMAScript与DOM/BOM
	1. 1996-08， 包含JScript的IE3.0发布
	2. 1996-11，Netscape将JavaScript提交给ECMA
	3. 1997-06，ECMA-262发布
	4. JavaScript=ECMAScript+DOM+BOM
*** Gmail与Google V8
	1. 2004-04-01，Gmail发布
	2. 2005-02-08，Google Maps发布，后又推出街景服务
	3. 2008-09-02，Google Chrome发布，一同面世的还有V8
*** 新浪潮中的前端框架
	1. DOM操作：jQuery/ExtJS/YUI
	2. 结构化前端框架：AngularJS/Backbone.js/Ember.js
*** Node.js为何选择了JavaScript
	1. JavaScript原生支持异步
	2. 历史包袱
	3. 开发门槛低
*** Fibjs
*** 全栈语言： JavaScript
	1. 前端 AngularJS BackBone.js
	2. 后端 node.js fib:js
	3. 移动端 PhoneGap React Native
** Node.js的特点
*** 部署简单方便
	1. 环境配置简单，只需要安装Node.js即可
	2. 注重约定
	3. 项目所需要扩展、插件、资源相对独立，不易冲突
*** 事件驱动
	主要观点：根据当前出现的事件，调动资源进行相关的处理。
*** 异步编程
	大部分的语言都是以同步的方式编写代码。

	异步的实现方式：
	1. 回调函数
	2. 事件监听
	3. 订阅/发布
*** 高效与性能
	1. 单个操作的性能并不优于其他解决方案
	2. 通过优化资源调配和I/O操作来实现高效
	
    其他语言对I/O的处理：
	1. PHP： 原地等待，开多进程
	2. C/C++： 利用线程，程序要自己维护线程和资源的状态
*** 单线程与多进程
	Google V8是单线程的，所以Node.js与同样是单进程的。为了更好的利用
	CPU资源，可以利用子进程和多进程：
	1. 子进程： Node.js的child_process模块，用于非node.js的代码
	2. 多进程： PM2等第三方工具
*** Node.js的缺点
	1. 大量采用匿名函数，使得抛出的异常不易阅读
	2. try/catch限于同步代码，使得异常捕获较为复杂
	3. 单线程：可靠性
	4. 不适合CPU密集型的场景
	5. 回调的代码习惯影响阅读
* Node.js开发环境搭建
** Node.js开发环境介绍
   MEAN Stack： MongoDB、Express、AngularJS、Node.js

   什么是全栈？

   WEB全栈
   1. HTML/CSS页面的构建
   2. 浏览器端的开发
   3. 服务器端的开发
   4. 数据库管理
   5. 服务器运维

   JavaScript可以开发哪些栈？
** Node.js的执行环境
   1. Google V8
   2. 文件系统
   3. 网络功能（HTTP/TCP/UDP/DNS/TLS/SSL）
   4. 二进制数据
   5. 数据流
   6. 加密与解密
** Mac OS开发环境介绍
   到Mac官方网站下载XCode，然后下载homebrew，
   #+BEGIN_SRC sh
brew install nodejs
node --version
# 安装文档数据库
brew install mongodb
mongo --version
# 安装缓存
brew install redis
   #+END_SRC
   
   接下来可以安装Subline或WebStorm。
** Windows开发环境介绍
   1. 生产环境中的Node.js应用
   2. Windows+Linux
   3. VirtualBox
   4. 虚拟机安装CentOS

   在虚拟机里进行软件的安装，
   #+BEGIN_SRC sh
yum install epel-release
yum install nodejs -y
yum install mongodb-server -y
yum install mongodb
mongo --version
yum install redis -y
redis-cli --version
   #+END_SRC
* 创建Web服务器和TCP服务器
** 使用http模块创建Web服务器
*** Web服务器基本知识
	Web服务器功能：
	1. 接受请求（GET、POST、DELETE、PUT、PATCH）
	2. 处理HTTP请求（自己处理，或请求别的程序处理）
	3. 做出响应（返回页面、文件、各类数据等）

    常见的Web服务器架构：
	1. Nginx/Apache： 负责接受HTTP请求，确定谁来处理请求，并返回请求的结果
	2. PHP-fpm/php模块： 处理分配给自己的请求，并将处理结果返回给分配者

    常见请求种类：
	1. 请求文件： 包括静态文件（网页、图片、前端JavaScript文件、CSS文件...），及由程序处理得到的文件
	2. 完成特定的操作： 如登录、获取特定数据等

    Node.js的Web服务器：
	1. 不依赖其它特定的Web服务器软件（如Apache、Nginx、IIS等）
	2. Node.js代码处理请求的逻辑
	3. Node.js代码负责Web服务器的各种“配置”
*** 使用核心模块http创建Web服务器
	下面开始创建Web服务器，代码如下：
	#+BEGIN_SRC sh
emacs web.js
var http = require('http');

var requestHandler = function(req, res){
    res.end('hello');
};

var web = http.createServer(requestHandler);

web.listen(18000);

console.log('http running on http://localhost:18000');
	#+END_SRC

	接下来使用node来执行web.js文件，
	#+BEGIN_SRC sh
node web.js
	#+END_SRC

	使用curl命令测试我们的程序，
	#+BEGIN_SRC sh
curl http://localhost:18000
	#+END_SRC
** 使用Express创建Web服务器
   一般使用Express第三方模块来开发Web服务器。

   本节的内容如下：
   1. 简单的Express服务器
   2. 静态文件服务
   3. 路由
   4. 中间件

   创建源代码，
   #+BEGIN_SRC sh
emacs express.js
var express = require('express');

var app = express();

app.get('/', function(req, res){
    res.end('hello\n');
});

app.listen(18001, function afterListen(){
    console.log("express running on http://localhost:18001");
});
   #+END_SRC

   接下来使用npm包管理工具安装express模块，
   #+BEGIN_SRC sh
yum install -y npm
npm install express
   #+END_SRC

   接下来执行express.js脚本，
   #+BEGIN_SRC sh
node express.js
   #+END_SRC

   可以使用express的模板，安装express的generator，
   #+BEGIN_SRC sh
npm install -g express-generator
express expressHello
cd expressHello
ll
npm install
   #+END_SRC

   静态文件范围：
   1. 网页
   2. 纯文本
   3. 图片
   4. 前端JavaScript代码
   5. CSS样式表文件
   6. 媒体文件
   7. 字体文件

   使用Express创建静态文件服务器，修改express.js的代码，
   #+BEGIN_SRC sh
emacs express.js
var express = require('express');

var app = express();

app.use(express.static('./public'));

app.get('/', function(req, res){
    res.end('hello\n');
});

app.listen(18001, function afterListen(){
    console.log("express running on http://localhost:18001");
});
   #+END_SRC

   在项目目录，创建public目录并创建test.txt文件，
   #+BEGIN_SRC sh
mkdir public
echo "This is a static file test" > public/test.txt
   #+END_SRC

   Express的路由，
   #+BEGIN_SRC sh
http://xxxx.com/2016/xxx.html
http://php.net/downloads.php
http://xxx.com/mission/daily
   #+END_SRC

   路由：
   1. 将不同的请求，分配给相应的处理函数
   2. 区分：路径、请求方法
   
   路由实现的3种方法：
   1. path
   2. 

   具体的代码为：
   #+BEGIN_SRC sh
emacs express.js
var express = require('express');

var app = express();

app.use(express.static('./public'));

app.get('/', function(req, res){
    res.end('hello\n');
});

var Router = express.Router();
/*
  http://example.com/post/add
  http://example.com/post/list
*/

Router.get('/add', function(req, res){
    res.end('Router /add\n');
});

Router.get('/list', function(req, res){
    res.end('Router /list\n');
});

app.use('/post', Router);

app.listen(18001, function afterListen(){
    console.log("express running on http://localhost:18001");
});
   #+END_SRC

   接着运行express.js脚本，并用curl进行测试，
   #+BEGIN_SRC sh
node express.js
curl http://localhost:18001/post/list
curl http://localhost:18001/post/add
   #+END_SRC

   接着修改express.js脚本，使用route()方法，
   #+BEGIN_SRC sh
emacs express.js
var express = require('express');

var app = express();

app.use(express.static('./public'));

app.get('/', function(req, res){
    res.end('hello\n');
});

var Router = express.Router();
/*
  http://example.com/post/add
  http://example.com/post/list
*/

Router.get('/add', function(req, res){
    res.end('Router /add\n');
});

Router.get('/list', function(req, res){
    res.end('Router /list\n');
});

app.use('/post', Router);

app.route('/article')
  .get(function(req, res){
    res.end('route /article get\n');
  });
  .post(function(req, res){
    res.end(route /article post\n);
  });

app.listen(18001, function afterListen(){
    console.log("express running on http://localhost:18001");
});
   #+END_SRC

   运行express.js并做测试，
   #+BEGIN_SRC sh
curl -X POST http://localhost:18001/article
   #+END_SRC

   路由参数，
   #+BEGIN_SRC sh
emacs express.js
var express = require('express');

var app = express();

app.use(express.static('./public'));

app.get('/', function(req, res){
    res.end('hello\n');
});

var Router = express.Router();
/*
  http://example.com/post/add
  http://example.com/post/list
*/

Router.get('/add', function(req, res){
    res.end('Router /add\n');
});

Router.get('/list', function(req, res){
    res.end('Router /list\n');
});

app.use('/post', Router);

app.route('/article')
  .get(function(req, res){
    res.end('route /article get\n');
  });
  .post(function(req, res){
    res.end(route /article post\n);
  });

// http://example.com/new/123

app.param('newsId', function(req, res, next, newId){
    req.newsId = newsId;
    next();
});

app.get('/news/:newsId', function(req, res){
    res.end('newsId:' + req.newsId + '\n');
});

app.listen(18001, function afterListen(){
    console.log("express running on http://localhost:18001");
});
   #+END_SRC

   #+BEGIN_SRC sh
   curl http://localhost:18001/news/123
   #+END_SRC
*** 中间件
	1. Connect： Node.js的中间件框架
	2. 分层处理
	3. 每层实现一个功能

	一个例子，安装日志中间件Morgan，
	#+BEGIN_SRC sh
emacs express.js
var express = require('express');
var morgan = require('morgan');

var app = express();

app.use(express.static('./public'));
app.use(morgan());

app.get('/', function(req, res){
    res.end('hello\n');
});

var Router = express.Router();
/*
  http://example.com/post/add
  http://example.com/post/list
*/

Router.get('/add', function(req, res){
    res.end('Router /add\n');
});

Router.get('/list', function(req, res){
    res.end('Router /list\n');
});

app.use('/post', Router);

app.route('/article')
  .get(function(req, res){
    res.end('route /article get\n');
  });
  .post(function(req, res){
    res.end(route /article post\n);
  });

// http://example.com/new/123

app.param('newsId', function(req, res, next, newId){
    req.newsId = newsId;
    next();
});

app.get('/news/:newsId', function(req, res){
    res.end('newsId:' + req.newsId + '\n');
});

app.listen(18001, function afterListen(){
    console.log("express running on http://localhost:18001");
});
	#+END_SRC

	使用npm包管理工具进行安装Morgan，
	#+BEGIN_SRC sh
npm install morgan
	#+END_SRC
** 创建TCP服务器
   本节的主要内容如下：
   1. 使用net模块创建TCP服务器
   2. 使用Telnet连接TCP服务器
   3. 使用net创建TCP客户端

*** 创建服务端
   创建一个tcp.js脚本，
   #+BEGIN_SRC sh
emacs tcp.js

const PORT = 18001;
const HOST = '127.0.0.1';

var net = require('net');

var clientHandler = function(socket){
    console.log('someone connected');

    socket.on('data', function dataHandler(data){
        console.log(socket.remoteAddress, socket.remotePort, 'send', data);
    });

    socket.on('close', function(){
        console.log(socket.remoteAddress, socket.remotePort, 'disconnected');
    });
};

var app = net.createServer(clientHandler);

app.listen(PORT, HOST);
console.log('tcp server running on tcp://', HOST, ':', PORT);
   #+END_SRC

   运行tcp.js，并用telnet工具进行测试，
   #+BEGIN_SRC sh
node tcp.js
telnet localhost 18001
this is a client
   #+END_SRC

   这时，我们发现tcp.js的输出数据是Unicode编码格式，我们需要在程序里修
   改data，把data修改为data.toString()，完整的tcp.js代码为，
   #+BEGIN_SRC sh
cat tcp.js
emacs tcp.js

const PORT = 18001;
const HOST = '127.0.0.1';

var net = require('net');

var clientHandler = function(socket){
    console.log('someone connected');

    socket.on('data', function dataHandler(data){
        console.log(socket.remoteAddress, socket.remotePort, 'send', data.toString());
    });

    socket.on('close', function(){
        console.log(socket.remoteAddress, socket.remotePort, 'disconnected');
    });
};

var app = net.createServer(clientHandler);

app.listen(PORT, HOST);
console.log('tcp server running on tcp://', HOST, ':', PORT);
   #+END_SRC

   服务器端也可以向客户端发送数据，修改tcp.js文件，增加socket.write()函数调用，
   #+BEGIN_SRC sh
emacs tcp.js

const PORT = 18001;
const HOST = '127.0.0.1';

var net = require('net');

var clientHandler = function(socket){
    console.log('someone connected');

    socket.on('data', function dataHandler(data){
        console.log(socket.remoteAddress, socket.remotePort, 'send', data);
        socket.write('server received\n');
    });

    socket.on('close', function(){
        console.log(socket.remoteAddress, socket.remotePort, 'disconnected');
    });
};

var app = net.createServer(clientHandler);

app.listen(PORT, HOST);
console.log('tcp server running on tcp://', HOST, ':', PORT);
   #+END_SRC
*** 创建客户端
	创建tcpClient.js脚本，
	#+BEGIN_SRC sh
var net = require('net');

const HOST = '127.0.0.1';
const PORT = 18001;

var tcpClient = net.Socket();

tcpCient.connect(PORT, HOST, function(){
    console.log('connect successfully');
    tcpClient.write('this is tcp client by Node.js');
});

tcpClient.on('data', function(data){
    console.log('received: ', data.toString());
});
	#+END_SRC
* Node.js开发工具的使用
** 开发工具的使用
   1. Sublime Text
   2. WebStorm

   VirtualBox的NAT转发规则设置。
*** Sublime Text
   按着Ctrl，滚动鼠标滚轮，可以放大或缩小字体。

   多行编辑： 使用Ctrl选中多行，进行编辑

   多个变量同时更改，选中变量，按alt+3进行所有变量的更改。

   Control Package的安装，到官网查看安装方式。按Ctrl+~，粘贴复制的命令，回车。

   安装完毕，重启Sublime Text编辑器。

   点击“Preference->Control package"，搜索“sftp”，进行安装，它的功能是与Linux服务器同步文件，

   在Windows机器上创建项目目录，并到Sublime里设置，添加目录到项目。

   Map to Remote，编辑sftp-config.json文件，host，user，password，远程的目录。

   go to anything，Ctrl-P。
*** WebStorm
	使用试用版本。
** NPM与调试工具的使用
*** NPM
	#+BEGIN_SRC sh
yum install -y npm
	#+END_SRC

	可以安装国内的npm源，
	#+BEGIN_SRC sh
npm config set strict-ssl false
# -g 表示全局选项
npm install -g cnpm --registry=https://registry.npm.taobao.org/
	#+END_SRC

	安装express模块，
	#+BEGIN_SRC sh
mkdir hello
cd hello
cnpm install express
ls
# express会被安装到node_modules目录下
# 安装nodemon
cnpm install -g nodemon

	#+END_SRC
*** nodemon
	#+BEGIN_SRC sh
# 使用nodemon监视hello.js文件
# nodemon hello.js
# 接着编辑hello.js文件，保存，验证nodemon是否重启hello.js脚本
	#+END_SRC
*** pm2
	#+BEGIN_SRC sh
# 安装pm2
cnpm install -g pm2
	#+END_SRC
*** node-inspector
	#+BEGIN_SRC sh
cnpm install -g node-inspector
emacs app.js
var http = require('http');

http.createServer(function(req, res){
    res.end('Hello\n');
}).listen(8011);
	#+END_SRC

	运行app.js脚本，
	#+BEGIN_SRC sh
nodemon --debug app.js
	#+END_SRC

	再打开一个终端标签，
	#+BEGIN_SRC sh
cd /home/hello
node-inspector
	#+END_SRC

	接着打开Chrome浏览器，输入URL“http://192.168.20.160:8080/debug?ws=192.168.20.160:8080&port=5858”
*** Chrome Developer Tools
* Node.js编程：语句 函数 变量
** 语句
   通常，代码是从上到下依次执行。
*** 条件语句
	#+BEGIN_SRC sh
if (numAge <= 12) {
    // statement
}
	#+END_SRC

	#+BEGIN_SRC sh
if (numAge <= 12) {
    // statement
} else {
    // statement
}
	#+END_SRC
*** 循环语句
	#+BEGIN_SRC sh
while (boolean_expression) {
   // statement
}
	#+END_SRC

	#+BEGIN_SRC sh
do {
} while ();
	#+END_SRC

	#+BEGIN_SRC sh
for (var i = 0; i <= numMax; i++) {
    // 
}
	#+END_SRC

	#+BEGIN_SRC sh
# 用于对数组或对象的遍历
var o = {
    a: 1,
    b: 2,
    c: 'str',
    d: false
};

for (var key in o) {
    console.log('key: ', key, 'value: ', o[key]);
}
	#+END_SRC
*** 分支语句
	#+BEGIN_SRC sh
switch (表达式、变量或值) {
  case 值或表达式:
    //语句
    break;
  case 值或表达式:
    //语句
    break;
  default:
    //语句
    break;
}
	#+END_SRC

	一个例子，
	#+BEGIN_SRC sh
var s = 'str';

switch (s) {
  case "str":
    console.log('is str');
    break;
  case false:
    console.log('is boolean false');
    break;
  default:
    console.log('default statement');
    break;
}
	#+END_SRC

	当有多个case语句都满足条件时，只有第一个case执行。
*** break与continue
	break终止本次循环

	continue终止本次循环，继续下一次循环
*** label语句
	当有多个循环嵌套时，用得着。

	#+BEGIN_SRC sh
for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 2; j++) {
    console.log('i : ', i, 'j: ', j);
  }
}
	#+END_SRC

	程序稍作修改，
	#+BEGIN_SRC sh
for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 2; j++) {
    console.log('i : ', i, 'j: ', j);
    if (i === 1) {
      break;
    }
  }
}
	#+END_SRC

	#+BEGIN_SRC sh
outter: for (var i = 0; i < 3; i++) {
  inner: for (var j = 0; j < 2; j++) {
    console.log('i : ', i, 'j: ', j);
    if (i === 1) {
      break outter;
    }
  }
}
	#+END_SRC
*** with语句
	#+BEGIN_SRC sh
var req = {
	session: {
	  user: {
	    name: 'lavenliu',
	    sex: 'male'
	  }
        }
};

req.session.user.name;
req.session.user.sex;

with (req.session.user) {
	console.log('name: ', name, 'sex: ', sex);
}
	#+END_SRC
** 函数
   实现特定功能的代码组合。

   使用表达式方式定义的函数，要放在文件的开头，也就是先定义后使用。
*** 基本使用
	#+BEGIN_SRC sh
function sum(numA, numB) {
    console.log('sum: ', numA + numB);
}

# 函数是对象，可以像变量一样定义
# 最后一个参数作为函数体
# 前面的参数作为新函数的参数
var sum2 = new Function(
    'numA',
    'numB',
    'console.log("sum2: ", numA + numB);'
);

# 另外的简化定义形式
var sum3 = function(numA, numB) {
    console.log('sum3: ', numA + numB);
};
	#+END_SRC

	接下来函数的调用，
	#+BEGIN_SRC sh
sum(1, 2);
sum2(1, 2);
sum3(1, 2);
	#+END_SRC

	返回值，
	#+BEGIN_SRC sh
console.log(sum(1, 2));
# 如果没有返回值，就会返回一个undefined。
# 添加返回值
function sum(numA, numB) {
    console.log('sum: ', numA + numB);
    return numA + numB;
}
	#+END_SRC
*** 参数
	不约定参数的类型及个数，参数按值传递。

	#+BEGIN_SRC sh
function testArg() {
    console.log('arguments: ', arguments);
    console.log('argument count: ', arguments.length);
    console.log('first argument: ', arguments[0]);
}

testArg(1, 2, 3, 4);
	#+END_SRC
*** 特点
	1. 匿名函数，尽量不要使用匿名函数
	2. 回调函数，把函数作为一个参数传入另外一个函数
	3. 函数有其属性与方法，如length属性
	  
    一个脚本，
	#+BEGIN_SRC sh
var fs = require('fs');

fs.readFile(__filename, 'utf8', function(err, data){
    console.log('readFile err, data: ', err, data);
});
	#+END_SRC
** 变量
*** 变量的值
	一个变量只是作为一个名字而存在。

	变量有基本类型与引用类型的值。
*** 属性与方法
*** 定义
	使用var来进行定义。

	所有的变量都会被编译器预先定义，其默认值为undefined。
	#+BEGIN_SRC sh
var strA = 'strA';

console.log('strA: ', strA);
# 如果只有一句呢
console.log('strA: ', strA);
# 报错
# 如果交换两行的位置呢
console.log('strA: ', strA);
var strA = 'strA';
# undefined
	#+END_SRC

	定义的提前。

	不使用var进行定义的变量就是全局变量。
	#+BEGIN_SRC sh
var gA = 'gA';

function testGlobal() {
    var gB = 'gB'; # 使用var与不使用var进行定义
    console.log('gA: ', gA);
}

testGlobal();
console.log('gB: ', gB);
	#+END_SRC

	推荐在文件顶部定义全局变量。

	常量，
	#+BEGIN_SRC sh
const CONST_VAR = 1;

console.log('CONST_VAR: ', CONST_VAR);

CONST_VAR = 2; # 对常量进行修改，不会生效，也不会报错

console.log('CONST_VAR: ', CONST_VAR);
	#+END_SRC
* 使用MongoDB存储数据
  MongoDB是NoSQL数据库，没有行列的概念，有集合、文档的概念。
** MongoDB的基本使用
*** 特点
	1. 使用BSON存储数据
	   #+BEGIN_SRC sh
二进制的JSON
	   #+END_SRC
	2. 支持相对丰富的查询操作
	3. 支持索引
	4. 副本集
	5. 分片
	6. 无模式
	7. 部署简单方便
*** 服务的启动
	1. MongoDB运行的两种方式
	2. 启动命令的使用

	#+BEGIN_SRC sh
mkdir -p /data/db
# 前台方式的执行
mongod --dbpath=/data/db --port=27017
# 守护进程的执行，输出日志到系统日志
mongod --dbpath=/data/db --port=27017 --fork --syslog
mongod --dbpath=/data/db --port=27017 --fork --logpath=/var/log/mongod.log
# 关闭mongod进程
mongod --shutdown
	#+END_SRC
*** 命令行工具的基本使用
	#+BEGIN_SRC sh
mongo
# 或
mongo 127.0.0.1:27017
# 查看数据库
show dbs
# 可以直接创建数据库，只有在插入数据时，集合才会被创建
use part9
# 插入数据
db.users.insert({"username": "lavenliu"});
show dbs;
show collections
# 查看集合里的所有文档
db.users.find()
db.users.insert({"username": "taoqi", "group": "reporter"});
db.users.find();
# _id字段是必须有的
db.users.find().count(); # 链式写法
db.users.insert({"username": "taoqi01", "group": "programmer"});
db.users.find();
# 指定查询条件
db.users.find({"_id": ObjectId("xxxx")});
# 更新
db.users.update({"username": "taoqi"}, {$set: {"group": "writer"}});
db.users.update({"username": "taoqi01"}, {$set: {"group": "coder"}}, {multi: true});
# 查询
db.users.find();
# save形式的修改，必须要指定_id
db.users.save("_id": ObjectId("xxx"), "group": "reporter");
# 删除
db.users.remove({"group": "reporter"});
db.users.find();
# 删除，指定单行删除
db.users.remove({"group": "reporter"}, true);
# 全部删除
db.users.remove({});
# 或
db.users.drop();
	#+END_SRC
** 使用Mongoose模块操作MongoDB
   mongoose将Node中的对象与MongoDB中的文档对应起来。
*** 模块介绍
	#+BEGIN_SRC sh
cd /opt/node
mkdir part9
cd part9
cnpm install mongoose
	#+END_SRC
*** 配置与连接
	#+BEGIN_SRC sh
cat model.js
var mongoose = require('mongoose');

var uri = 'mongodb://username:password@hostname:port/database_name';
uri = "mongodb://localhost/part9";

mongoose.connect(uri);

var BookSchema = new mongoose.Schema({
    name: String,
    author: String,
    publishTime: Date
});

mongoose.model('Book', BookSchema);
	#+END_SRC
*** Model与Schema
	mongoose模块通过提供Model建立与Node中的对象与MongoDB中的文档对应的功能。

	Schema来实现model中数据类型的定义。

	#+BEGIN_SRC sh
var BookSchema = new mongoose.Schema({
    name: String,
    author: String,
    publishTime: Date
});

mongoose.model('Book', BookSchema);
	#+END_SRC
*** 创建文档
	#+BEGIN_SRC sh
cat insert.js
var mongoose = require('mongoose');
require('./model.js');

var Book = mongoose.model('Book');

var book = new Book({
    name: "MEAN Web Development",
    author: "Green",
    publishTime: new Date()
});

book.author = 'Laven';

book.save(function(err){
    console.log('save status: ', err ? 'failed' : 'success');
});
	#+END_SRC
*** 简单查询
	#+BEGIN_SRC sh
cat find.js
var mongoose = require('mongoose');

require('./model.js');

var Book = mongoose.model('Book');

Book.find({}, function(err, docs){
    if (err) {
        console.log('err: ', err);
        return;
    }

    console.log('result: ', docs);
});
	#+END_SRC

	查找一条数据，
	#+BEGIN_SRC sh
cat findOne.js

	#+END_SRC
*** 删除文档
*** 条件语句
** 在Express项目中使用Mongoose
   实践：一个使用Mongoose存储数据的Express项目。
* JavaScript语言基础
** 语法
*** 标识符
*** 严格模式
*** 注释与语句
*** 关键字与保留字
** 数据类型
*** 变量
*** 数据类型的分类
*** 简单数据类型
*** 复杂数据类型
*** typeof
** 操作符
*** 一元操作符
*** 位操作符
*** 布尔操作符
*** 四则运算操作符
*** 关系操作符
*** 条件操作符
*** 赋值操作符
*** 逗号操作符
* ECMAScript引用类型
** Object类型
** 基本包装类
** Global对象
** Math对象
* Mongoose使用进阶
** 模式的扩展
** 型的方法
** 数据的校验
** 中间件
** DERef
* ECMAScript数组
** 初始化和检查
** 转换和排序
** 栈和队列操作
** 其他操作
