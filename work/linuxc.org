* History and Standards
** A Brief History of UNIX and C
** A Brief History of Linux
** Standardization
** Summary
* Fundamental Concepts
  本章将会介绍一些与Gnu/Linux系统编程相关的概念。
** The Core Opearting System: The Kernel
   “操作系统”术语通常具有两种不同的含义：
   1. 广泛地讲，操作系统是一个大而全的中央软件，既可以管理计算机的资源，
	  也提供标准的工具软件，诸如命令行解释器（CMD）、图形化的用户接口
	  （GUI）、文件实用工具（File Utilies）和编辑器（Editor）等。
   2. 狭隘地讲，操作系统指的是管理和分配计算机资源（如，CPU资源、RAM资
	  源和其他设备等）的一个中央软件。

   内核（kernel）术语通常被认为是上述第二种含义的一个中央软件，在接下
   来的整篇文章中将内核与操作系统同等看待。

   尽管在没有内核的操作系统上也可能运行起来程序，但有了内核的存在可以
   极大地简化书写及使用其他程序，并且可以增加程序员的效率及编程的灵活
   性。内核通过提供一个软件层来管理一个计算机的有限资源。

   #+BEGIN_EXAMPLE
   Aside: Linux内核可执行文件通常是/boot/vmlinuz或其他类似的。
   该名字的来历有点历史。在早期的UNIX发行版中，内核通常叫做unix。在后来的UNIX
   发行版中，提出了虚拟内存技术，内核的名字随之更改为了vmunix。在Linux里，文件名反映了
   系统名字，使用字母z替代了最后一个x以表明Linux内核是一个可执行的压缩文件。
   #+END_EXAMPLE
*** Tasks performed by the kernel
	除了上面的内核的介绍，内核还完成以下任务：
	1. 进程调度
	   #+BEGIN_EXAMPLE
	   一个计算机上有一个或多个中央处理器单元（CPUs），用来执行程序的指令。
	   与其他UNIX系统类似，Linux是一个抢占式多任务的操作系统，多任务意味着
	   多个进程（如，运行的多个程序）可以同时驻留内存并且每个进程都会获得CPU(s)的使用。
	   抢占式意味着进程得到CPU的使用及使用多长时间的规则控制权由内核进程调度决定（这些规则控制权而非进程本身决定）。
	   #+END_EXAMPLE
	2. 内存管理
	   #+BEGIN_EXAMPLE
	   在过去的10到20年间，计算机的内存容量已得到极大增加，系统软件也有相应的变大，
	   所以，物理仍然是一个有限的资源，内核必须在进程中公平及有效的共享。与绝大多数
	   系统相似，Linux采用虚拟内存管理的方式，该技术有如下两个主要的优势：
	   #+END_EXAMPLE
	   + 进程之间彼此孤立及进程与内核之间也是孤立的，所以一个进程不能
         读取或者修改其他进程或内核的内存空间。
	   + 如果只需进程的一部分被保留在内存中，内核就会降低该进程的内存
         需求，并且允许节更多的进程同时驻留在内存。这样可以更好地使用
         CPU，因为在任意时刻，至少有一个进程被CPU执行。
	3. 提供文件系统
	   #+BEGIN_EXAMPLE
	   内核在硬盘上提供了文件系统，允许文件被创建、检索、更新、删除等。
	   #+END_EXAMPLE
	4. 创建与终止进程
	   #+BEGIN_EXAMPLE
	   内核可以加载新的程序到内存，并提供该进程一些所需资源（如，CPU、内存及访问文件）以运行该进程。
	   运行中的程序的一个实例通常叫做一个进程。一旦一个进程执行完毕，内核就会确保释放该进程所使用的资源，
	   以供后来的程序再次使用。
	   #+END_EXAMPLE
	5. 访问设备
	   #+BEGIN_EXAMPLE
	   附加在计算机上的设备（如鼠标、显示器、键盘、硬盘和磁带驱动等）允许计算机与外界进行通信交流，允许输入和输出。
	   内核提供程序一些接口使得程序访问设备变得标准化及简化，与此同时内核仲裁多个进程
	   #+END_EXAMPLE
	6. 网络
	   #+BEGIN_EXAMPLE
	   内核代表用户进程传输和接收网络数据包。这些任务包括路由网络包到目标系统。
	   #+END_EXAMPLE
	7. 提供系统调用API
	   #+BEGIN_EXAMPLE
	   进程可以使用内核的入口点，通常叫做系统调用以请求内核执行一些任务。Linux的系统调用API将是本书的首要话题。
	   #+END_EXAMPLE

    除了上述特点外，多用户操作系统如Linux通常提供用户一个虚拟专用计算
    机的抽象；那就是每个用户可以登录到计算机系统并且用户的一些操作与系
    统中的其他用户在很大程度上是独立的。例如，每个用户有自己的硬盘存储
    空间（家目录）。另外，用户还可以运行程序，每个程序都可以获得CPU资
    源并且在各自的虚拟内存空间进行操作，这些程序可以独立的访问设备并且
    通过网络彼此传输信息。这些程序的访问硬件资源时，内核解决潜在的访问
    冲突，所以用户和进程通常毫无察觉这些冲突。
*** Kernel mode and user mode
** The Shell
   shell是一个具有特殊目的程序，被设计用来读取用户输入的命令并执行适当的程序来响应
   用户敲入的命令。诸如这样的一个程序有时候也被称为命令解释器。

   术语login shell用来表示当用户登录系统时，一个进程被创建并运行了shell程序。

   然而在一些操作系统上，命令解释器是内核的一部分，在UNIX及类UNIX系统
   中，shell是一个用户进程。操作系统可以存在不同的shell，并且不同的用
   户在同一台计算机上可以同时使用多种不同的shell程序。在操作系统的发展过程中，涌现出了
   一些重要的shell：
   1. Bourne shell（sh）：这是最古老、最广泛使用的shell，是由Steve
      Bourne开发。它是UNIX第7版本的标准shell程序。Bourne shell包含了所
      有shell程序中都有一些特性：I/O重定向、管道线、文件名匹配、变量、
      环境变量操作、命令替换、后台执行命令和函数等。包括后来的UNIX发行
      版及Bourne shell之外的其他shell也提供这些特性。
   2. C shell（csh）：
   3. Korn shell（ksh）：
   4. Bourne again shell（bash）：

   shell的设计不仅仅是为了交互式的使用，而且还可以解释shell脚本，shell脚本就是
   一些包含shell命令的文本文件。
** Users and Groups
   操作系统中的每个用户都有一个唯一的标识（通常是UID），并且用户可以隶
   属于某个组。
*** Users
	操作系统中的每一个用户都有一个唯一的登录名称（username）和一个与之
	相对应的数字ID（即UID）。对于每个用户来说，它们是定义在系统的密码
	文件/etc/passwd里的，每一行表示一个用户，每一行都有一些额外的信息，
	如：
	1. 组ID：
	2. 家目录：用户登录系统后所在的初始目录。
	3. 登录shell：用户登录后使用什么程序（如，/bin/sh或/bin/bash等）来
	   解析自己的命令。

	密码文件里还包含用户的密码，不过是已加密的形式。一般安全起见，密码
	位通常分开存放，保存在影子密码文件中，通常只有授权用户可以读取。
*** Groups
	特别地，出于系统管理的目的，为了控制文件和其他系统资源的访问，把用
	户归类到组是非常有用的。举例来说，如果一个团队的成员正在开发一个单
	一的工程，并且共享该工程下的一系列文件，那最好的做法就是把他们归为
	同一个组。在早期的UNIX发行版，一个用户只能属于一个组。BSD系列允许
	用户同时属于多个组，这个想法被其他的UNIX发行版所采纳并形成后来的
	POSIX.1990标准。每个组在系统组文件/etc/group中以一行来标识，该行包
	含以下信息：
	+ 组名：组的唯一名称。
	+ 组ID：一个数字ID并关联到该组。
	+ 用户列表：该组下的用户列表，多个用户使用逗号分开。
*** Superuser
	在操作系统里有一个超级用户，它对操作系统具有特殊的权限。超级用户
	也有一个UID，它的UID为0，并且登录系统时显示的用户名为root。在典型
	的UNIX系统中，超级用户会通过所有的权限检测，如超级用户可以访问系
	统的任意文件，而不管该文件具有何种权限设置；超级用户可以发送信号
	到任何其他用户进程。管理用户在系统中使用超级账户来执行诸多管理任务。
** Single Directory Hierarchy, Directories, Links and Files
*** File types
	在文件系统里，每个文件都被标识为某一种类型以表示该文件是什么。这些
	类型中的一种文件类型是普通的数据文件，它们通常被称为常规文件或文本
	文件，以此区分其他类型的文件。除此之外的文件类型还有设备、管道、套
	接字、目录和软链接等。

	文件这一术语通常表示任何类型的文件，而不仅仅是一个常规文件。在UNIX
	及类UNIX系统中，一切皆文件。
*** Directories and links
	目录是一种特殊的文件，它的内容是该目录下的文件名称列表，每个文件名
	指向对应的具体文件。文件名+指向的组合通常叫做链接，所以文件可以有
	多个连接及多个名称，这些链接可以位于相同或不同的目录中。

	目录中可以包含既可以指向文件又可指向目录的链接。

	每个目录至少包含两个目录项，".(dot)"是一个指向当前目录的一个链接，
	"..(dot-dot)"是一个指向当前目录的父目录的链接（当前目录的上一级目
	录）。除了根目录外，每个目录都有一个父目录。对于根目录而言，".."目
	录是指向根目录自身的（即，/..等同于/）。
*** Symbolic links
	与一般的链接类似，一个符号链接
*** Filenames
	在大多数的Linux文件系统上，文件名最大为255个字符长度。文件名可以是
	除斜线(/)和空字符(\0)外的任意字符。不过建议只使用字符与数字、点(.)、
	下划线(_)和连字符(-)等字符。这65个字符集[-._a-zA-Z0-9]在SUSv3中被
	提及并作为可移植的文件名字符集。

	我们应该避免使用可移植文件名字符集之外的字符，因为这些字符在shell
	里、正则表达式里或其他上下文可能具有特殊含义。在一个上下文环境中，
	如果一个文件名包含了这些具有特殊意义的字符，这些字符一定要转义；那
	就是特殊意义的字符前加一个反斜线(\)以标识它不被解释为特殊含义，就
	是抑制它的特殊含义。

	我们还应该避免在文件名的开头使用连字符(-)，那会被shell误以为是某个
	命令的选项。比如一个名为“-liu”的文件怎么被创建及删除呢？如果我们直
	接使用touch命令来创建的话，会出现以下错误提示：
	#+BEGIN_SRC sh
[root@mydevops ~]# touch -liu
touch: invalid option -- 'l'
Try `touch --help' for more information.
	#+END_SRC
	系统提示说没有"-l"的选项，要创建该文件可以通过两个连写的连字符来转
	义这个文件名前的连字符，
	#+BEGIN_SRC sh
touch -- -liu
[root@mydevops ~]# ls -l -- -liu
-rw-r--r-- 1 root root 0 Mar 31 17:23 -liu
	#+END_SRC
	
	如何删除呢，是不是你已经知道了？
*** Pathnames
	表示一个路径名，通常有两种方式，既可以是绝对的也可以是相对的：
	1. 绝对路径名 - 以/开始定位文件。如/usr/local/src/test.c。
	2. 相对路径名 - 相对一个进程的当前工作目录去定位一个文件。
*** Current working directory
	每个进程都有一个当前工作目录（有时就是指进程的工作目录或当前目录）。
	一个登陆的shell有它自己的初始当前工作目录，也就是家目录，它是由
	/etc/passwd文件决定的。shell的当前工作目录可以使用cd命令进行切换。
*** File ownership and permisssions
** File I/O Model
   UNIX系统I/O模型的一个突出特点是它的通用性。这就意味着相同的系统调用
   （如open()，read()，write()，close()等）可以用来执行所有类型的文件
   及设备在内的I/O操作（内核翻译应用程序的I/O请求到合适的文件系统或设
   备驱动器上，并操作目标文件或设备以执行相应的I/O动作）。因此，一个程
   序可以利用这些系统调用在任何类型的文件上进行操作。

   内核本质上提供了一种文件类型：一系列的字节流，所以，诸如硬盘文件，
   硬盘和磁道设备等文件类型，可以使用lseek()系统调用进行随机访问。

   很多应用程序和库解释newline字符（对应ASCII码中十进制数字10，通常称
   为换行）为终止一行文本并开始下一行文本。UNIX系统没有end-of-file字符，
   一个读操作可以检测文件的末尾，当遇到文件的末尾时将不会返回数据。
*** File descriptors
	I/O相关的系统调用通常使用文件描述符（通常是一个较小的非负整数）指
	向一个打开的文件。一个文件描述符通常由open()调用获得，open()需要一
	个路径名作为其参数来指定一个文件，然后执行何种I/O操作。

	一般地，当一个进程被shell启动时会继承3个文件描述符：文件描述符0表
	示标准输入，进程从这里获得输入；文件描述符1表示标准输出，进程将使
	用此作为自己的输出；文件描述符2是标准错误输出，进程将自己的错误信
	息和异常通知或终止状态写入到此文件。在一个交互式shell或程序中，这3
	个文件描述符通常连接到终端上。在stdio库中，这些描述符相应的指向文
	件流stdin，stdout和stderr。
*** The stdio library
	为了执行文件I/O操作，C程序典型地会使用I/O函数，这些函数通常由标准C
	库提供。这些函数集由stdio库提供，stdio库中包含fopen()，
	fclose(),scanf()，printf()，fgets()，fputs()等等。stdio库中的函数
	在系统I/O调用（open()，close()，read()，write()等等）之上。
** Programs
   程序通常以两种形式存在。一种是源代码，它是人类可读的并包含了一些使
   用编程语言书写的语句，例如C语言。为了执行已编译好的源程序，源代码必
   须被转换为第二种形式：机器可以理解的二进制机器指令（与脚本比较，脚
   本就是一个文本文件且包含了一些命令直接被命令解释器处理）。由于源程
   序通过编译和链接后在语义上等同二进制的机器码，所以程序的这两种存在
   形式通常被认为是同义词。
*** Filters
	一个过滤器通常用来从标准输入读取一个程序的输入，然后把输入的内容进
	行一些转换或处理，然后把转换或处理后的数据输出到标准输出。一些常见
	的过滤器程序如cat、grep、tr、sort、wc、sed和awk等。
*** Command-line arguments
	C程序可以接受命令行参数，就是程序运行时，在命令行提供给程序的参数。
	如果要让程序接受命令行参数，程序的main()函数要做如下声明：
	#+BEGIN_SRC C
int main(int argc, char *argv[])
	#+END_SRC
	argc变量保存着所有的命令行参数的个数，每个参数都被看做是字符串指针
	指向数组argv。argv数组的第一个元素就是程序本身。
** Processes
   简而言之，进程就是一个正在运行的程序的一个实例。当一个程序被执行时，
   内核加载程序的代码到虚拟内存，为程序的变量分配内存空间，并设置内核
   的数据结构记录关于该进程的一些信息（诸如进程ID、进程终止状态、进程
   的用户ID及组ID等）。

   从内核的角度看，内核必须为进程分配计算机所拥有的资源。由于资源是有
   限的，如内存，内核刚开始为进程分配一定量的计算机资源，并在程序的生
   命周期内，按照程序的需求及系统的总体需求，调整进程所需的资源。当进
   程终止时，所有与该进程相关的资源都会被释放，并为其他进程重新使用。
   诸如其他资源，如CPU和网络带宽属于可持续使用的资源，但必须公平地被所
   有的进程共享使用。
*** Process memory layout
	一个进程逻辑上被划分为以下几个部分，通常称为段：
	1. 文本段：程序的指令
	2. 数据段：存放程序的静态变量
	3. 堆段：为程序提供动态分配内存的区域
	4. 栈段：保存函数调用信息及局部变量
*** Process creation and program execution
*** Process ID and parent process ID
	每一个进程都有一个唯一的数字标识，也就是进程标识（PID）。每个进程
	也都有一个父进程标识（PPID）属性，用来表明该父进程要求内核创建该进
	程的子进程。
*** Process termination and termination status
*** Process user and group identifiers(credentials)
*** Privileged processes
*** Capablities
*** The init process
	当启动系统时，内核创建了一个特殊的进程叫做init，init进程是所有进程
	的父进程，init进程由/sbin/init程序而来。

	所有的系统进程要么是被init直接创建，要么是init的创建的其他进程创建
	（使用fork()系统调用）。init进程的PID始终为1并且运行时具有超级用户
	的权限。init进程不能被kill掉（即使是超级用户也不行），只有系统在关
	闭时它才随之被终止。init进程的主要任务是创建并监控一系列的进程来满
	足一个运行的系统（可以init(8)的帮助手册来获得详细的信息）。
*** Daemon processes
	一个守护进程是一个具有特殊目的的进程，与其他进程一样，也是由系统创
	建及操控。相对于其他进程而言，守护进程有如下两个明显的特点：
	1. 长期运行的。守护进程常常随着操作系统的启动而开始运行，并且一直运行直到系统关闭为止。
	2. 后台运行，守护进程通常没有控制终端，所以它既不能从终端读取输入或者写内容到输出。

    常见的守护进程包括syslogd，通常记录系统的日志信息；httpd守护进程，
    通过HTTP协议来提供web服务。
*** Environment list
*** Resource limits
** Memory Mappings
** Static and Shared Libraries
*** Static libraries
*** Shared libraries
** Interprocess Communication and Synchronization
** Signals
** Threads
** Process Groups and Shell Job Control
** Sessions, Contorlling Terminals, and Contorlling Processes
   一个session是一个进程组（jobs）。所有的进程在该session里有相同的
   session标识。一个session leader就是创建该session的进程，并且该进程
   的进程ID也就是该进程创建的session的ID。
** Pseudoterminals
** Date and Time
** Client-Server Architecture
** Realtime
** The /proc File System
   与其他UNIX发行版的实现一样，Linux提供了一个/proc文件系统，在此目录
   下面挂载了一些目录和文件。

   /proc文件系统是一个虚拟的文件系统，它提供了一个内核接口，通过此接
   口，我们可以查看内核的一些数据结构，通常这些数据结构对人类并不易读，
   而/proc文件系统的主要工作就是把这些内核的数据结构映射成目录或文件
   的形式到此目录。因此，我们可以通过/prox提供的这种机制，来查看或修
   改系统的属性。另外，诸如/proc/PID这样的目录，PID指的是正在运行的进
   程ID标识，通过查看此目录下的文件内容，我们可以看到每个正在运行进程
   信息。

   /proc文件系统中的文件通常是人类易读的文本格信息，并可以通过shell脚
   本来解析这些信息。一个程序可以从中读取（查看）或写入（修改）该目录
   下面的指定文件。在多数情况下，一个进程必须要有足够的权限才能修改
   /proc目录下的文件。

   /proc文件系统并不是任何一个标准所规定的，在12.1章节我们将详细介绍
   Linux下的标准。
** Summary
* System Programming Concepts
** System Calls
   本章将包含与系统编程相关的一些预备知识。在本章的开始会介绍系统调用以及系统调用执行的细节。
   然后会介绍库函数（GNU C Library）以及库函数与系统调用的区别。

   无论何时我们使用系统调用或者库函数调用，我们应该总是检查这些调用的返回状态以确认是否成功。
   我们描述如何进行这些检查，并呈现贯穿本书所使用的例行检查的一些程序。
* File I/O: The Universal I/O Model
  本章我们开始从系统的重要的系统调用API处着手。文件是一个很好的开始，
  因为它们是UNIX的哲学。本章重点介绍执行文件的输入与输出的系统调用。

  我们介绍文件描述符的概念，然后接着介绍与I/O模型相关的系统调用。这些
  系统调用是打开与关闭一个文件，然后进行读取和写入数据。

  我们重点关注硬盘文件的I/O，更多地应该是在后续章节介绍的，因为这些相
  同的系统调用可以用来对所有类型的文件进行I/O操作，诸如管道和终端等。

  在第5章，我们将更详细地介绍I/O相关的操作。文件I/O的另一方面，缓冲，
  是相对复杂并可以独立成章地介绍。第13章介绍kernel中的I/O缓冲和stdio库。
** Overview
   所有的系统调用都是使用文件描述符对打开的文件执行I/O操作，文件描述符
   通常是一个较小的非负整数。文件描述符用来指向所有的打开的文件，包括
   管道，FIFOs，套接字，终端，设备和常规文件。

   约定俗成的，绝大多数的程序都可以使用三个标准文件描述符，
   | 文件描述符 | 作用     | POSIX名称     | stdio流 |
   |------------+----------+---------------+---------|
   |          0 | 标准输入 | STDIN_FILENO  | stdin   |
   |          1 | 标准输出 | STDOUT_FILENO | stdout  |
   |          2 | 标准错误 | STDERR_FILENO | stderr  | 

   当程序启动时，程序就会从它的shell中获得这些文件描述符。更精确地说，
   程序是从shell中继承了这三个文件描述符的副本。

   当使用这三个文件描述符时，我们既可以通过其相应的整数值或使用在
   <unistd.h>头文件中的POSIX标准名字。

   以下是4个关键的执行文件I/O的系统调用：
   1. fd=open(pathname, flags, mode) 打开pathname所代表的文件，并返回
      一个文件描述符供后续的调用。如果要打开的文件不存在，open()将会创
      建该文件，这取决于flags参数。flags参数指定文件被如何打开，是读取、
      写入或者两者都是等。mode参数指定文件的权限，当文件被创建时会用到。
      如果open()调用不是用来创建的文件用的，mode参数可以省略。
   2. numread=read(fd, buffer, count) 从fd指向的文件读取最多count个字
      节，并把读取到内容存放在buffer中。read()调用返回实际读取的字节数。
      如果没有其他字节可以被读取（遇到end-of-file时），read()将返回0。
   3. numwrite=write(fd, buffer, count) 从buffer读取至多count个字节写
      入到fd指向的文件。write()调用返回实际的写入字节数，有时会少于
      count字节数。
   4. status=close(fd) 当所有的I/O执行完毕，可以调用close()，主要是为
      了释放文件描述符。文件描述符属于内核资源，如果一直占用不释放，有
      可能导致其他进程将不能使用该资源。

   接下来我们看一个简单的文件复制程序，该程序从命令行接收两个参数，把
   第一个参数文件的内容复制到第二个参数文件中。代码如下：
   #+BEGIN_SRC C
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>

#ifndef BUF_SIZE
#define BUF_SIZE 1024
#endif

int main(int argc, char *argv[])
{
    int     input_fd, output_fd, open_flags;
	mode_t  file_perms;
	ssize_t num_read;

	/* open input files */
	input_fd = open(argv[1], O_RDONLY);
	if (input_fd == -1) {
		printf("opening file %s error.\n", argv[1]);
		exit(1);
	}

	/* open output files */
	open_flags = O_CREAT | O_WRONLY | O_TRUNC;
	file_perms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |
		S_IROTH | S_IWOTH; /* rw-rw-rw- */
	output_fd = open(argv[2], open_flags, file_perms);
	if (output_fd == -1) {
		printf("opening file %s error.\n", argv[2]);
		exit(1);
	}

	/* transfer data until we encounter eof or an error */
	while ((num_read = read(input_fd, buf, BUF_SIZE)) > 0) {
		if (write(output_fd, buf, num_read) != num_read) {
			perror("could not write whole buffer");
			exit(2);
		}
	}

	if (num_read == -1) {
		perror("read error");
		exit(1);
	}

	/* close the opened file descriptor */
	if (close(input_fd) == -1) {
		perror("close error");
		exit(1);
	}

	if (close(output_fd) == -1) {
		perror("close error");
		exit(1);
	}
	
    return 0;
}
   #+END_SRC

   接下来进行编译，假设上面的源文件名为copy.c，则操作如下：
   #+BEGIN_SRC sh
gcc -o copy copy.c
   #+END_SRC
** Universality of I/O
   UNIX I/O模型的一个特点之一就是一般性I/O的概念。这就意味着4个系统调
   用open()，read()，write()和close()可以在所有文件类型上执行I/O操作，
   包括设备和终端。如果我们的程序只使用这些函数的话，那我们的程序可以
   操作所有类型的文件。我们可以通过上面的copy程序进行演示：
   #+BEGIN_SRC sh
./copy test test.old
./copy a.txt /dev/tty
./copy /dev/tty b.txt
./copy /dev/pts/16 /dev/tty
   #+END_SRC

   一般性I/O实现的就是让每个文件系统与设备驱动都使用相同的I/O系统调用。
   因为文件系统及设备驱动的详细细节由内核处理，所以，当我们书写应用程
   序时，我们一般可以忽略设备相关的因素。当我们要使用文件系统或设备的
   某个指定的特性时，我们可以使用全能的ioctl()系统调用，该系统调用提供
   一个接口，以供超出一般性I/O模型的范畴时使用。
** Opening a File: open()
   open()系统调用可以打开一个已存在的文件，或创建并打开一个新的文件。
   open()系统调用的函数原型为：
   #+BEGIN_SRC sh
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags, ... /* mode_t mode */);
                       Returns file descriptor on success, or –1 on error
   #+END_SRC
   将要打开的文件由pathname参数标识。如果pathname是一个符号链接，那么
   该文件将被间接引用。如果调用成功，open()返回一个文件描述符，该文件
   描述符就指向了这个已打开的文件，也可以在后续的系统调用当中使用此文
   件描述符。如果调用失败，则返回-1并且errno也会被相应的设置。

   flags参数是位掩码用来指定访问文件时的方法（读、写、读写或追加等），
   常用的参数如下：
   | 访问mode | 说明             |
   |----------+------------------|
   | O_RDONLY | 只读模式打开文件 |
   | O_WRONLY | 只写模式打开文件 |
   | O_RDWR   | 读写模式打开文件 | 

   当使用open()创建一个文件时，mode参数用来指定新建文件的权限位。如果
   open()调用不指定O_CREAT，mode可以忽略。

   我们在15.4章节详解介绍文件权限相关的，我们将会看到新建文件的权限不
   仅仅是由mode参数决定，而且还有进程的umask决定，以及该文件父目录的访
   问控制列表等决定。我们可以使用八进制的数值来指定mode参数，通常较多
   使用的是使用位掩码与0进行逻辑或操作来指定mode。

   下面看一个例子，主要是使用open()，并且指定flags参数，代码如下：
   #+BEGIN_SRC C
/* Open existing file for reading */
fd = open("startup", O_RDONLY);
if (fd == -1)
	errExit("open");
/* Open new or existing file for reading and writing, truncating to
   zero bytes; file permissions read+write for owner, nothing for all
   others */
fd = open("myfile", O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
if (fd == -1)
	errExit("open");
/* Open new or existing file for writing; writes should always append
   to end of file */
fd = open("w.log", O_WRONLY | O_CREAT | O_TRUNC | O_APPEND,
		  S_IRUSR | S_IWUSR);
if (fd == -1)
	errExit("open");
   #+END_SRC
** Writing to a File: write()
   write()系统调用写数据到一个打开的文件。

   当我们对一个磁盘文件执行I/O操作时，成功返回并不能保证数据已写入到磁
   盘，主要是因为内核在执行磁盘I/O时的缓冲机制，该机制主要是为了减少磁
   盘的活动与加快write()的调用。
** Closing a File: close()
** Changing the file Offset: lseek()
   对于一个打开的文件，内核记录了一个文件偏移，有时也称为读写偏移或指
   针。这个位置位于下一次的read()或write()发生时。文件偏移是相对文件开
   始位置按顺序的。文件的开始处的偏移是0。

   The file offset is set to point to the start of the file when the
   file is opened and is automatically adjusted by each subsequent
   call to read() or write() so that it points to the next byte of the
   file after the byte(s) just read or written. Thus, successive
   read() and write() calls progress sequentially through a file.

   The lseek() system call adjusts the file offset of the open file
   referred to by the file descriptor fd, according to the values
   specified in offset and whence.

   函数原型为：
   #+BEGIN_SRC sh
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
               Returns new file offset if successful, or –1 on error
# fd - 对哪个文件调整其文件偏移
# offset - 调整多少
# whence - 从fd的何处开始
# whence的取值：
#   SEEK_SET - 从文件的开始，加上offset
#   SEEK_CUR - 从文件当前的偏移开始，加上offset
#   SEEK_END - 从文件末尾开始，加上offset
   #+END_SRC
   当whence为SEEK_CUR或SEEK_END时，offset可以为负值；当whence为
   SEEK_SET时，offset一定是非负的。

   lseek()的返回值是一个新的文件偏移。下面的调用可以在不改变文件偏移的
   情况下，获得文件的当前文件偏移，
   #+BEGIN_SRC C
curr = lseek(fd, 0, SEEK_CUR);
   #+END_SRC

   常见的lseek()的使用形式：
   #+BEGIN_SRC C
lseek(fd, 0, SEEK_SET);      /* Start of file */
lseek(fd, 0, SEEK_END);      /* Next byte after the end of the file */
lseek(fd, -1, SEEK_END);     /* Last byte of file */
lseek(fd, -10, SEEK_CUR);    /* Ten bytes prior to current location */
lseek(fd, 10000, SEEK_END);  /* 10001 bytes past last byte of file */
   #+END_SRC

   Calling lseek() simply adjusts the kernel’s record of the file
   offset associated with a file descriptor. It does not cause any
   physical device access.

   We can’t apply lseek() to all types of files. Applying lseek() to a
   pipe, FIFO, socket, or terminal is not permitted; lseek() fails,
   with errno set to ESPIPE. On the other hand, it is possible to
   apply lseek() to devices where it is sensible to do so. For
   example, it is possible to seek to a specified location on a disk
   or tape device.

   说到lseek系统调用，不得不说一下File Holes（文件洞）。有这样一个情形，
   当我们在文件末尾进行seek操作，然后执行I/O操作会发生什么呢？如果这时
   调用read()将会返回0，表明以到达文件的末尾。似乎有一些奇怪，但往文件
   末尾处的后面写任意的内容还是可以的。

   从文件末尾到新的数据写入这段空的空间，被称为文件洞。从编程的角度来
   看，在文件洞处的字节是存在的，从这些文件洞读取的内容包含的全是
   0（null bytes）。

   然后，文件洞不是这样的，它并占用任何的磁盘空间。文件系统并没有为它
   分配磁盘块，直到之后有数据写入的某个时刻。这种特性的优势是文件洞稀
   疏文件并占用较少的磁盘空间。Core dump文件通常就是这种形式的文件包含
   了巨大的文件洞。

   The statement that file holes don’t consume disk space needs to be
   qualified slightly. On most file systems, file space is allocated
   in units of blocks (Section 14.3). The size of a block depends on
   the file system, but is typically something like 1024, 2048, or
   4096 bytes. If the edge of a hole falls within a block, rather than
   on a block boundary, then a complete block is allocated to store
   the data in the other part of the block, and the part corresponding
   to the hole is filled with null bytes.

   Most native UNIX file systems support the concept of file holes,
   but many nonnative file systems (e.g., Microsoft’s VFAT) do not. On
   a file system that doesn’t support holes, explicit null bytes are
   written to the file.
* File I/O: Further Details
* Processes
* Memory Allocation
* Users and Groups
  每一个用户都有一个唯一的登录名称和一个相关联的数字标识，这个数字标
  识也就是我们常说的UID。每个用户既可以是一个组的成员也可以隶属于多个
  其他组的成员。但每一个组也都有一个唯一的名称和数字标识，这个数字标
  识就是我们常说的GID。

  设计用户和组的IDs的主要目的有两个：一是确定系统资源隶属哪个系统用户；
  二是当进程访问这些系统资源时应该授予什么样的权限控制。例如，每一个
  文件都是属于一个特定用户和组，每一个进程都有一些用户和组IDs以确定谁
  拥有该进程和这些进程访问文件时所具有的什么样的权限。

  本章节中，我们将探讨一些系统文件，如/etc/passwd、/etc/groupd等。这
  些文件里定义了系统的用户和组的信息。然后会介绍一些库函数来从这些文
  件中检索用户信息。结束时，我们还会介绍crypt()函数，它是用来加密和认
  证登录密码的。
** The Password File: /etc/passwd
   系统的密码文件是/etc/passwd，里面包含了用户的账户信息，一行表示一
   个用户。每一行由半角的分号分隔共有7个字段，如
   #+BEGIN_EXAMPLE
   lavenliu:x:1000:1000:Laven Liu:/home/lavenliu:/bin/bash
   #+END_EXAMPLE

   下面按顺序逐一说明每个字段的含义：
   1. 用户名           - lavenliu
   2. 加密的密码       - x
   3. 用户UID          - 1000
   4. 用户GID          - 1000
   5. 用户说明         - Laven Liu
   6. 用户家目录       - /home/lavenliu
   7. 用户登录的shell  - /bin/bash
** The Shadow Password File: /etc/shadow
** The Group File: /etc/group
** Retrieving User and Group Information
*** Retrieving records from the password file
*** Retrieving records from the group file
** Password Encryption and User Authentication
** Summary
** Exercises
* Process Credentials
* Time
* System Limits and Options
* System and Process Information
* File I/O Buffering
* File Systems
* File Attributes
* Extended Attributes
* Access Control Lists
* Directories and Links
  这一章通过目录和链接来探讨文件相关的话题。对文件和目录的实现进行总体
  概览，然后我们探讨创建与移除目录和链接的系统调用。然后，我们使用库函
  数以让程序扫描一个单个目录里的内容，然后遍历一个目录树。

  每个进程有两个与目录相关的属性：一个根目录，用来决定程序的绝对路径；
  一个是当前工作目录，用来决定程序的相对目录。可以使用系统调用允许一个
  进程修改这两个属性。

  最后，我们使用库函数来解析一个路径名并解析成路径名与文件名。
** Directories and (Hard) Links
   一个目录与一个常规的文件相似，也是存储在文件系统之中。但有两点区分
   一个文件是目录文件而非常规文件：
   1. 一个目录在i-node条目中被标识为不同的文件类型。
   2. 一个目录文件有特别的组织形式。特别地，目录是一个表，包含了目录下
      的文件名及i-node号。

   举例说明/etc/passwd文件，来阐述目录与i-node之间的关系。
   #+BEGIN_SRC sh
[root@mydevops unix]# ls -i -d /
2 /
[root@mydevops unix]# ls -i -d /etc
1046529 /etc
[root@mydevops unix]# ls -i /etc/passwd
1058433 /etc/passwd
   #+END_SRC

   尽管一个进程可以打开一个目录，但它不能使用read()来读取一个目录的内
   容。为了检索一个目录的内容，一个进程必须使用接下来要介绍的系统调用
   与库函数调用（在一些UNIX的发行版中，可以对一个目录执行read()函数，
   但是这样做并不具有可移植性）。一个进程也不能使用write()函数来修改一
   个目录的内容，但它可以间接地通过系统调用（要求内核）改变目录的内容，
   诸如，open()，link()，mkdir(), symlink()，unlink()和rmdir()。

   i-node表的编号是从数字1开始而非0开始，因为0在一个目录条目的i-node中
   表示该条目未被使用。i-node 1用来记录一个文件系统的坏块。一个文件系
   统中的根目录的i-node编号总是2，因此，内核知道从何处开始解析一个路径
   名。

   回顾第14.4章节，我们知道i-node并不包含文件名，it is only the
   mapping within a directory list that defines the name of a
   file. This has a useful consequence: we can create multiple
   names—in the same or in different directories—each of which refers
   to the same i-node. These multiple names are known as links, or
   sometimes as hard links to distinguish them from symbolic links,
   which we discuss shortly.

   接下来我们看看硬链接是何东东？我们首先创建一个常规文件，然后使用ln
   命令来创建该文件的一个链接（硬链接），
   #+BEGIN_SRC sh
[root@mydevops ~]# echo -n "Hello," > hello
[root@mydevops ~]# ls -li hello 
2095751 -rw-r--r-- 1 root root 6 May 31 10:43 hello
[root@mydevops ~]# ln hello world
[root@mydevops ~]# echo " world" >> world
[root@mydevops ~]# cat abc
Hello, world
[root@mydevops ~]# ls -li hello world 
2095751 -rw-r--r-- 2 root root 13 May 31 10:46 hello
2095751 -rw-r--r-- 2 root root 13 May 31 10:46 world
   #+END_SRC
   从以上的结果中，我们可以看到hello与world文件的i-node是一样的。并且
   通过cat命令查看，它们的文件内容也是一样的，因为它们指向的是同一个
   i-node条目，这就是它们是一个文件的原因。使用ls -li的输出的第3列，我
   们可以看到该i-node的链接数。在使用ln hello world命令后，hello文件的
   链接数已经由原来的1变成2了，因为现在有两个名字同时指向了hello文件
   （world文件也有同样的链接数，因为它们都是指向的同一个i-node条目）。
** Symbolic (Soft) Links
** Creating and Removing (Hard) Links: link() and unlink()
** Changing the Name of a File: rename()
** Working with Symbolic Links: symlink() and readlink()
** Creating and Removing Directories: mkdir() and rmdir()
** Removing a File or Directory: remove()
** Reading Directories: opendir() and readdir()
* Monitoring File Events
* Signals: Fundamental Concepts
* Signals: Signal Handlers
* Signal: Advandced Features
* Timers and Sleeping
* Process Creation
  在本章及下一章，我们将探讨一个进程如何被创建及其终止；一个进程如何可
  以执行一个新的程序。这一章着重介绍进程的创建。在深入探讨话题之前，先
  看一下这几章都会使用到的系统调用。
** Overview of fork(), exit(), wait() and execve()
   本章及接下来的几章都将会使用到系统调用fork()，exit()，wait()和execve()。
* Process Termination
* Monitoring Child Processes
* Program Excution
* Process Creation and Program Excution in More Detail
* Threads: Introduction
* Threads: Thread Synchronization
* Threads: Thread Safety and Per-Thread Storage
* Threads: Thread Cancellation
* Treads: Futher Details
* Process Groups, Sessions, and Job Control
* Process Priorities and Scheduling
* Process Resources
* Daemons
  本章我们将检查守护进程的一些特点并且看一下需要哪些步骤可以把一个进程
  变为守护进程。我们还会看到如何让守护进程使用syslog设备记录日志信息。
** Overview
   一个守护进程通常有如下特性：
   1. 长期存活。通常，一个守护进程在系统启动时创建并直到系统终止而终止
      运行。
   2. 守护进程运行在后台并且没有控制终端。由于缺少了控制终端可以确保内
      核永远不会向一个守护进程自动产生任何作业控制或与终止相关的信号
      （如SIGINT，SIGSTP和SIGHUP）等动作。

   守护进程通常是用来完成指定任务的，举例阐述，如下：
   1. cron：在预定的时间执行命令的一个守护进程。
   2. sshd：安全的shell的守护进程，允许远程主机使用一个安全的通信协议登录系统。
   3. httpd：HTTP服务器的守护进程，提供网页服务。
   4. inetd：互联网的超级服务器守护进程，用来监听指定的TCP/IP端口并启
      动合适的服务程序来处理入站的网络请求。
** Creating a Daemon
   为了成为守护进程，一个程序通常要执行如下两个步骤：
   1. 执行fork()函数，
	  - 
	  - 
   2. 子进程调用setsid()函数来开启一个新的session并且释放自己与所有控
      制终端的关联。
   3. 清除进程的umask
   4. 改变进程的当前工作目录
   5. 关闭所有打开的文件描述符
** Guidelines for Writing Daemons
** Using SIGHUP to Reinitialize a Daemon
** Logging Messages and Errors Using syslog
** Summary
** Exercise
* Writing Secure Privileged Programs
* Capabilities
* Login Accounting
* Fundamentals of Shared Libraries
* Interprocess Communication Overview
* Pipes and FIFOs
* Introduction to System V IPC
* System V Message Queues
* System V Semaphores
* System V Shared Memory
* Memory Mappings
* Virtual Memory Operations
* Introduction to POSIX IPC
* POSIX Message Queues
* POSIX Semaphores
* POSIX Shared Memory
* File Locking
* Sockets: Introduction
* Sockets: UNIX Domain
* Sockets: Fundamentals of TCP/IP Networks
* Sockets: Internet Domains
* Sockets: Advandced Topics
* Terminals
** 终端的基本概念
   在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为
   Shell进程的控制终端（Controlling Terminal），控制终端是保存在PCB中
   的信息，而我们知道fork会复制PCB中的信息，因此由Shell进程启动的其他
   进程的控制终端也是这个终端。默认情况下（没有重定向），每个进程的标
   准输入、标准输出和标准错误输出都是指向控制终端，进程从标准输入读也
   就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显
   示器上。

   每个进程都可以通过一个特殊的设备文件/dev/tty访问它的控制终端。事实
   上每个终端设备都对应一个不同的设备文件，/dev/tty提供了一个通用的接
   口，一个进程要访问它的控制终端既可以通过/dev/tty也可以通过该终端设
   备所对应的设备文件来访问。ttyname函数可以由文件描述符查出对应的文件
   名，该文件描述符必须指向一个终端设备而不能是任意文件。

   *查看终端对应的设备文件名*
   #+BEGIN_SRC sh
#include <unistd.h>
#include <stdio.h>

int main()
{
    printf("fd 0: %s\n", ttyname(0));
    printf("fd 1: %s\n", ttyname(1));
    printf("fd 2: %s\n", ttyname(2));
    return 0;
}
   #+END_SRC
   
* Alternative I/O Models
* Pseudoterminals
* Bash
** 信号处理
*** Linux信号回顾
	系统和应用程序可以生成30多个信号，最常用的信号如下表：
    | 信号 | 值      | 说明                       |
    |------+---------+----------------------------|
    |    1 | SIGHUP  | 挂起进程                   |
    |    2 | SIGINT  | 中断进程                   |
    |    3 | SIGQUIT | 停止进程                   |
    |    9 | SIGKILL | 无条件终止进程             |
    |   15 | SIGTERM | 如果可能的话终止进程       |
    |   17 | SIGSTOP | 无条件停止，但不终止进程   |
    |   18 | SIGSTP  | 停止或暂停进程，但不终止它 |
    |   19 | SIGCONT | 重新启动停止的进程         |
*** 生成信号
*** 捕获信号
*** 捕获脚本退出
*** 移除捕获
