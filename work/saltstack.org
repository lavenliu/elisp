#+TITLE: SaltStack自动化配置管理
#+AUTHOR: LavenLiu
#+DATE: 2015-09-27
#+EMAIL: ldczz2008@163.com 

#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[top=2.1cm,bottom=2.1cm,left=2.1cm,right=2.1cm]{geometry}
#+LaTeX_HEADER: \setmainfont[Mapping=tex-text]{Times New Roman}
#+LaTeX_HEADER: \setsansfont[Mapping=tex-text]{Tahoma}
#+LaTeX_HEADER: \setmonofont{Courier New}
#+LaTeX_HEADER: \setCJKmainfont[BoldFont={Adobe Heiti Std},ItalicFont={Adobe Kaiti Std}]{Adobe Song Std}
#+LaTeX_HEADER: \setCJKsansfont{Adobe Heiti Std}
#+LaTeX_HEADER: \setCJKmonofont{Adobe Fangsong Std}
#+LaTeX_HEADER: \punctstyle{hangmobanjiao}
#+LaTeX_HEADER: \usepackage{color,graphicx}
#+LaTeX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{colortbl}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage[bf,small,indentafter,pagestyles]{titlesec}

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style2.css" />

#+OPTIONS: ^:nil

* SaltStack
  主机名要可以解析。
* 快速入门
** 运行方式
   1. Local
   2. Master/Minion
   3. Salt SSH
** 三大功能
   1. 远程执行
   2. 配置管理
   3. 云管理
** 测试环境
   | 主机名                |         IP地址 | 说明   |
   |-----------------------+----------------+--------|
   | master01.lavenliu.com | 192.168.20.134 | Master |
   | minion01.lavenliu.com | 192.168.20.135 | Minion |
   | minion02.lavenliu.com | 192.168.20.136 | Minion |
** 安装部署
   在Master及Minion上安装EPEL源。
   #+BEGIN_EXAMPLE
   rpm -ivh http://mirrors.ustc.edu.cn/fedora/epel//6/x86_64/epel-release-6-8.noarch.rpm
   #+END_EXAMPLE
*** 安装Salt Master
     #+BEGIN_SRC sh
     yum install -y salt-master
     service salt-master start
     chkconfig salt-master on
     #+END_SRC

	 Master常用配置选项说明：
	 #+BEGIN_EXAMPLE
+ interface: 指定bind的地址(默认为0.0.0.0)
+ publish_port: 指定发布端口(默认为4506)
+ ret_port: 指定结果返回端口，与minion配置文件中的master_port对应(默认为4506)
+ user: 指定master进程的运行用户，如果调整，则需要调整部分目录的权限(默认为root)
+ timeout: 指定超时时间，如果minion规模庞大或网络状况不稳定，建议增大该值(默认5s)
+ keep_jobs: 默认情况下，minion会将执行结果返回给master，master会缓存到本地的cachedir目录，该参数指定缓存多长时间，以供查看之前
  的执行结果，会占用磁盘空间(默认为24h)
+ file_recv: 是否允许minion传送文件到master(默认False)
+ file_roots:
+ pillar_roots: 指定pillar目录，默认为:
+ log_level: 执行日志级别，支持的日志级别有"garbage", "trace", "debug", "info", "warning", "error", "critical" (默认warning)
	 #+END_EXAMPLE
*** 安装Salt Minion
     #+BEGIN_SRC sh
     yum install -y salt-minion
     #+END_SRC

	 Minion在启动之前，需要修改配置文件。告诉Minion，谁是它的Master。要
	 修改的地方如下：
	 #+BEGIN_EXAMPLE
	 master: 192.168.20.129
	 id: minion.saltstack.com
	 #+END_EXAMPLE
	 
	 Minion端怎么计算minion id：
	 #+BEGIN_EXAMPLE
	 The Salt minions will create their own ID based on their hostname. However,
	 hostname doesn't always mean the same thing to everyone.

	 When the minion starts up, if the ID has not already been set, the minion
	 will try to set it to a value that is not localhost using the following 
	 order:
	 1. The python function socket.getfqdn()
	 2. Check /etc/hostname
	 3. Check /etc/hosts

	 It is critical that every minion has a unique ID. Also, the minion will
	 cache that ID /etc/salt/minion_id. If we change the hostname, be aware that
	 the cache file will not automatically update. If we change the hostname,
	 stop the salt-minion daemon, delete that file, and then restart the 
	 salt-minion process. That should regenerate the cache file using the new
	 hostname.
	 #+END_EXAMPLE
	 
	 修改完毕，启动Minion服务：
	 #+BEGIN_EXAMPLE
     service salt-minion start
     chkconfig salt-minion on
	 #+END_EXAMPLE

	 Minion常用配置选项说明：
	 #+BEGIN_EXAMPLE
+ master: 指定master主机(默认为salt)
+ master_port: 指定认证和执行结果发送到master的哪个端口，与master配置文件中的ret_port对应(默认为4506)
+ id: 指定本minion的标识，salt内部使用id作为标识(默认为主机名)
+ user: 指定运行minion的用户，用于安装包、启动服务等操作需要特权用户，推荐使用root(默认root)
+ cache_jobs: minion是否
	 #+END_EXAMPLE
** 监听端口
   Once the minion ID is established, the master and minion can
   communicate along a ZeroMQ data bus. When the master sends out a
   command to ZeroMQ, it is said to "publish" events, and when the
   minions are listening to the data bus, they are said to "subscribe"
   to, or listen for those events - hense the descriptor pub-sub.

   When the master published a command, it simply puts it on the
   ZeroMQ bus for all of the minions to see. Each minion will then
   look at the command and the target (and the target type) to
   determine if it should run that command. If the minion determines
   that it does not match the combination of target and target type,
   then it will simply ignore that command.
   
   1. Master端
	  #+BEGIN_EXAMPLE
	  4505: publish port
	  4506: return port
	  #+END_EXAMPLE
   2. Minion端
	  #+BEGIN_EXAMPLE
	  启用大于1024的两个随机端口，建立与Master的4505及4506两个端口的TCP长连接。
	  #+END_EXAMPLE
** Master认证Minion
  Master与Minion的认证流程：
  
  在Master与Minion的/etc/salt目录下，都有一个pki的目录。Minion端在启
  动时会在/etc/salt目录下生成一个pki目录，里面有一个公钥也私钥。公钥
  在认证时会发送给Master端。

  PKI(Public Key Infrastructure)
  
  #+BEGIN_EXAMPLE
  master # tree
  .
  ├── master.pem
  ├── master.pub
  ├── minions
  │   └── minion.saltstack.com
  ├── minions_autosign
  ├── minions_denied
  ├── minions_pre
  │   └── linux-node2.example.com
  └── minions_rejected
   
  5 directories, 4 files
  #+END_EXAMPLE

  #+BEGIN_EXAMPLE
  # lsof -i:4505
  COMMAND    PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
  salt-mast 3736 root   12u  IPv4  28237      0t0  TCP *:4505 (LISTEN)
  salt-mast 3736 root   14u  IPv4  28940      0t0  TCP linux-node1.example.com:4505->linux-node2.example.com:34555 (ESTABLISHED)
  #+END_EXAMPLE

  使用salt-key命令
  #+BEGIN_EXAMPLE
  # salt-key -a <minion01>
  # salt-key -A
  # salt-key
  Accepted Keys:
  Denied Keys:
  Unaccepted Keys:
  linux-node2.example.com
  minion.saltstack.com
  Rejected Keys:
  # salt-key -a minion.saltstack.com
  The following keys are going to be accepted:
  Unaccepted Keys:
  minion.saltstack.com
  Proceed? [n/Y] Y
  Key for minion minion.saltstack.com accepted.

  # salt-key -d linux-node2.example.com
  The following keys are going to be deleted:
  Unaccepted Keys:
  linux-node2.example.com
  Proceed? [N/y] y
  Key for minion linux-node2.example.com deleted.
  #+END_EXAMPLE

  认证完毕，测试一下连通性：
  #+BEGIN_EXAMPLE
  # salt 'minion.saltstack.com' test.ping
  minion.saltstack.com:
	 True
  #+END_EXAMPLE
  
** SaltStack状态文件top.sls
  修改Master的文件，内容如下：
  #+BEGIN_EXAMPLE
  default_include: master.d/*.conf
  interface: 0.0.0.0
  state_top: top.sls
  file_roots:
  base:
	- /etc/salt/states
  prod:
	- /etc/salt/states/prod
  #+END_EXAMPLE

  创建相应的目录：
  #+BEGIN_EXAMPLE
  # mkdir -p /etc/salt/states/{init,prod}
  # cd /etc/salt/states
  # vim top.sls  # 注意格式，很重要(不允许使用tab键，并且是两个空格)。
  base:
	'minion.saltstack.com':
	  - init.pkg

  # cd init
  # vim pkg.sls
  pkg.init:
	pkg.installed:
	  - names:
		- tree
		- mtr
  #+END_EXAMPLE

  写完状态文件后，接下来就可以执行了。
  #+BEGIN_EXAMPLE
  # salt 'minion.saltstack.com' state.sls init.pkg
  minion.saltstack.com:
  ----------
			ID: pkg.init
	  Function: pkg.installed
		  Name: mtr
		Result: True
	   Comment: Package mtr is already installed.
	   Started: 14:03:18.255198
	  Duration: 847.442 ms
	   Changes:   
  ----------
			ID: pkg.init
	  Function: pkg.installed
		  Name: tree
		Result: True
	   Comment: The following packages were installed/updated: tree
	   Started: 14:03:19.102859
	  Duration: 13708.35 ms
	   Changes:   
				----------
				tree:
					----------
					new:
						1.5.3-3.el6
					old:
   
  Summary
  ------------
  Succeeded: 2 (changed=1)
  Failed:    0
  ------------
  Total states run:     2
  #+END_EXAMPLE

  管理配置文件：
  #+BEGIN_EXAMPLE
  # cd init
  # vim limit.sls
  limit-conf-config:
	file.managed:
	  - name: /etc/security/limits.conf
	  - source: salt://init/files/limits.conf
	  - user: root
	  - group: root
	  - mode: 644

  # 在top.sls里新增内容
  # cat top.sls
  base:
	'minion.saltstack.com':
	  - init.pkg
	  - init.limit
  #+END_EXAMPLE

  写完状态文件后，执行：
  #+BEGIN_EXAMPLE
  # salt 'minion.saltstack.com' state.highstate
  minion.saltstack.com:
  ----------
			ID: pkg.init
	  Function: pkg.installed
		  Name: mtr
		Result: True
	   Comment: Package mtr is already installed.
	   Started: 14:18:12.579446
	  Duration: 655.334 ms
	   Changes:   
  ----------
			ID: pkg.init
	  Function: pkg.installed
		  Name: tree
		Result: True
	   Comment: Package tree is already installed.
	   Started: 14:18:13.235064
	  Duration: 0.523 ms
	   Changes:   
  ----------
			ID: limit-conf-config
	  Function: file.managed
		  Name: /etc/security/limits.conf
		Result: True
	   Comment: File /etc/security/limits.conf updated
	   Started: 14:18:13.238258
	  Duration: 9.801 ms
	   Changes:   
				----------
				diff:
					---  
					+++  
					@@ -39,12 +39,17 @@
					 #<domain>      <type>  <item>         <value>
					 #
					 
					-#*               soft    core            0
					-#*               hard    rss             10000
					+*               soft    core            0
					+*               hard    rss             10000
					 #@student        hard    nproc           20
					 #@faculty        soft    nproc           20
					 #@faculty        hard    nproc           50
					 #ftp             hard    nproc           0
					 #@student        -       maxlogins       4
					 
					+# allow user 'elasticsearch' mlockall
					+elasticsearch soft memlock unlimited
					+elasticsearch hard memlock unlimited
					+                
					+
					 # End of file
   
  Summary
  ------------
  Succeeded: 3 (changed=1)
  Failed:    0
  ------------
  Total states run:     3
  #+END_EXAMPLE

  这时，可以到Minion端看以下/etc/security/limits.conf配置文件是否发生
  变化。
* 数据系统
  在学习配置管理前，要先学习salt的数据系统。
** Grains
	Granis是静态的，如果定义完毕grains后，不重启是不生效的。
	
	当Minion启动时，他会把Minion的详细情况会记录下来，如CPU，Memory、
	OS等信息。后面Master可以使用正则表达式来匹配Minion。
	1. 比如匹配OS为CentOS的系统的机器执行安装Apache。
	2. 配置管理中的配置文件中的IP及主机名
	3. 使用Grains做收集

    如何获得某台Minion的所有grains，
	#+BEGIN_SRC sh
salt 'mysql02.lavenliu.com' granis.items
# 显示某一个item
salt 'mysql02.lavenliu.com' granis.item os
mysql02.lavenliu.com:
    ----------
    os:
        CentOS
salt 'mysql02.lavenliu.com' granis.get os
mysql02.lavenliu.com:
    CentOS
	#+END_SRC

	在命令行可以使用-G参数，指定Grains，
	#+BEGIN_SRC sh
salt -G 'os:CentOS' test.ping
mysql02.lavenliu.com:
    True
nfs01.lavenliu.com:
    True
# salt -G 'fqdn:mysql02.lavenliu.com' test.ping
mysql02.lavenliu.com:
    True
	#+END_SRC
*** 如何自定义Grains
	 在Minion端定义，写到/etc/salt/minion文件里即可，
	 #+BEGIN_SRC sh
grains:
  roles: nginx
  env: prod
# 或者在minion端的/etc/salt目录下配置grains文件，里面只需要写键值对即可
# 如上面的例子可以这样写
roles: nginx
env: prod
	 #+END_SRC
	 修改完毕，重启minion端，
	 #+BEGIN_SRC sh
[root@mysql01 master]# salt -G 'role:nginx' test.ping
mysql02.lavenliu.com:
    True
[root@mysql01 master]# salt -G 'env:prod' test.ping
mysql02.lavenliu.com:
    True
	 #+END_SRC

	 刷新的命令，可以在定义完毕grains后，可以使用saltutil来刷新匹配，
	 而不需要重启minion服务了，
	 #+BEGIN_SRC sh
salt '*' saltutil.sync_granis
	 #+END_SRC

	 如何在SLS文件中使用自定义的Grains呢？
	 #+BEGIN_SRC sh
base:
  ...

  'role:nginx':
    - match: grain
    - init.pkg
	 #+END_SRC
** Pillar
	与Grains一样，给Minion定义任何需要的数据。

	Pillar主要用于敏感数据，只特定版本minion可以看到。

	Pillar可以定位目标，查看系统有哪些Pillar，
	#+BEGIN_SRC sh
salt 'mysql02.lavenliu.com' pillar.items
	#+END_SRC

	定义Pillar数据，修改Master的配置文件，取消pillar_roots的注释。
	#+BEGIN_SRC sh
pillar_roots:
  base:
    - /etc/salt/pillar
	#+END_SRC

	接下来创建自定义的Pillar，
	#+BEGIN_SRC sh
mkdir /etc/salt/pillar
cd /etc/salt/pillar

	#+END_SRC

	刷新pillar，
	#+BEGIN_SRC sh
[root@mysql01 ~]# salt '*' saltutil.refresh_pillar
mysql02.lavenliu.com:
    True
nfs01.lavenliu.com:
    True
# 查看自定义的Pillar
[root@mysql01 pillar]# salt '*' pillar.item syslog
nfs01.lavenliu.com:
    ----------
    syslog:
        rsyslog
mysql02.lavenliu.com:
    ----------
    syslog:
        rsyslog
	#+END_SRC

	pillar用在定位目标，
	#+BEGIN_SRC sh
[root@mysql01 ~]# salt -I 'syslog:rsyslog' test.ping
nfs01.lavenliu.com:
    True
mysql02.lavenliu.com:
    True
	#+END_SRC
** Grains vs. Pillar
   | 名称   | 存储位置 | 数据类型 | 数据采集更新方式                     | 应用                                     |
   |--------+----------+----------+--------------------------------------+------------------------------------------|
   | Grains | Minion端 | 静态数据 | Minion启动时收集，也可以使用         | 存储Minion基本数据。比如用于匹配Minion， |
   |        |          |          | saltutil.sync_grains进行刷新         | 自身数据可以用来做资产管理等。           |
   |--------+----------+----------+--------------------------------------+------------------------------------------|
   | Pillar | Master端 | 动态数据 | 在Master端定义，指定给对应的Minion。 | 存储Master指定的数据。只有指定的Minion   |
   |        |          |          | 可以使用saltutil.refresh_pillar刷新  | 可以看到，用于敏感数据保存。             |
* 远程执行
** 目标(Targeting)
   命令的语法格式：
   #+BEGIN_EXAMPLE
   salt '<target>' <function> [arguments]
   #+END_EXAMPLE

   1. target
	  #+BEGIN_EXAMPLE
	  # salt '*' test.ping
	  # salt '*.example.com' test.ping
	  # salt -G 'os:Ubuntu' test.ping
	  # salt -E 'virtmach[0-9]' test.ping
	  # salt -L 'foo,bar,baz,quo' test.ping
	  # salt -C 'G@os:Ubuntu and webser* or E@database.*' test.ping
	  #+END_EXAMPLE
	  target组件允许我们过滤出需要在哪些机器上进行执行function。
** 模块(Module)
	1. function
	   #+BEGIN_EXAMPLE
	   # salt '*' sys.doc
	   # salt '*' test.ping
	   # salt '*' cmd.run 'uname -a' # 执行任意的shell命令
	   #+END_EXAMPLE
	   function就是提供某种功能，通常有module提供。
	2. arguments
	   #+BEGIN_EXAMPLE
	   # salt '*' cmd.exec_code python 'import sys; print sys.version' 
	   minion.saltstack.com:
       2.6.6 (r266:84292, Jul 23 2015, 15:22:56) 
       [GCC 4.4.7 20120313 (Red Hat 4.4.7-11)]
	   #+END_EXAMPLE
	3. salt-cp
	   #+BEGIN_SRC sh
[root@mysql01 states]# salt-cp '*' /etc/hosts /tmp/hosts
{'mysql02.lavenliu.com': {'/tmp/hosts': True},
 'nfs01.lavenliu.com': {'/tmp/hosts': True}}
	   #+END_SRC
** 返回(Returners)
    #+BEGIN_SRC sh
    # salt '*' cmd.run 'uptime'
    minion.saltstack.com:
       14:31:56 up  1:09,  1 user,  load average: 0.00, 0.00, 0.00
	#+END_SRC
	
	在Master端安装MySQL Server，用来保存minion端的执行结果，在所有的
	minion端安装MySQL-python软件包。这个返回结果是minion端写入到MySQL
	数据库中的。然后在Master端或Minion端的配置文件中配置如下内容(最好
	在Minion端的配置文件中添加)：
	#+BEGIN_SRC sh
mysql.host: '192.168.20.158'
mysql.user: 'salt'
mysql.pass: 'salt'
mysql.db: 'salt'
mysql.port: 3306
	#+END_SRC

	创建salt returner所需的数据结构，
	#+BEGIN_SRC sql
create database salt default character set utf8 default collate utf8_general_ci;

USE `salt`;

--
-- Table structure for table `jids`
--

DROP TABLE IF EXISTS `jids`;
CREATE TABLE `jids` (
  `jid` varchar(255) NOT NULL,
  `load` mediumtext NOT NULL,
  UNIQUE KEY `jid` (`jid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
CREATE INDEX jid ON jids(jid) USING BTREE;

--
-- Table structure for table `salt_returns`
--

DROP TABLE IF EXISTS `salt_returns`;
CREATE TABLE `salt_returns` (
  `fun` varchar(50) NOT NULL,
  `jid` varchar(255) NOT NULL,
  `return` mediumtext NOT NULL,
  `id` varchar(255) NOT NULL,
  `success` varchar(10) NOT NULL,
  `full_ret` mediumtext NOT NULL,
  `alter_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  KEY `id` (`id`),
  KEY `jid` (`jid`),
  KEY `fun` (`fun`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Table structure for table `salt_events`
--

DROP TABLE IF EXISTS `salt_events`;
CREATE TABLE `salt_events` (
`id` BIGINT NOT NULL AUTO_INCREMENT,
`tag` varchar(255) NOT NULL,
`data` mediumtext NOT NULL,
`alter_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
`master_id` varchar(255) NOT NULL,
PRIMARY KEY (`id`),
KEY `tag` (`tag`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

grant all on salt.* to 'salt'@'192.168.20.%' identified by 'salt';
flush privileges;
	#+END_SRC

	执行一些命令，
	#+BEGIN_SRC sh
salt '*' test.ping --return mysql
nfs01.lavenliu.com:
    True
mysql02.lavenliu.com:
    True
	#+END_SRC

	接着查看数据库的信息，
	#+BEGIN_SRC sql
mysql> select * from salt_returns;
+-----------+----------------------+--------+----------------------+---------+--------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
| fun       | jid                  | return | id                   | success | full_ret                                                                                                                                         | alter_time          |
+-----------+----------------------+--------+----------------------+---------+--------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
| test.ping | 20160507114248682207 | true   | nfs01.lavenliu.com   | 1       | {"fun_args": [], "jid": "20160507114248682207", "return": true, "retcode": 0, "success": true, "fun": "test.ping", "id": "nfs01.lavenliu.com"}   | 2016-05-07 11:42:50 |
| test.ping | 20160507114248682207 | true   | mysql02.lavenliu.com | 1       | {"fun_args": [], "jid": "20160507114248682207", "return": true, "retcode": 0, "success": true, "fun": "test.ping", "id": "mysql02.lavenliu.com"} | 2016-05-07 11:42:50 |
+-----------+----------------------+--------+----------------------+---------+--------------------------------------------------------------------------------------------------------------------------------------------------+---------------------+
2 rows in set (0.00 sec)
	#+END_SRC

	还可以使用另外一种方法，使用Master端的cache功能，只需要在Master端
	配置，Minion端不需要安装MySQL-Python软件包了。Master端的配置很简单，
	配置如下：
	#+BEGIN_SRC sh
mysql.host: '192.168.20.158'
mysql.user: 'salt'
mysql.pass: 'salt'
mysql.db: 'salt'
mysql.port: 3306
master_job_cache: mysql
	#+END_SRC

	总结：可以使用returner或job_cache保存Minion端的返回结果。
	
* 配置管理
** 理解YAML
   SLS文件的默认渲染器是YAML渲染器。书写SLS文件只有简单的三条规则。

   1. 缩进 - (两个空格，非tab)
	  #+BEGIN_EXAMPLE
	  YAML uses a fixed indentation scheme to represent relationships
	  between data layers. Salt requires that the indentation for
	  each level consists of exactly two spaces. Do not use tabs.
	  #+END_EXAMPLE
	  缩进表示层级关系。
   2. 冒号 - (字典可以嵌套)
	  #+BEGIN_EXAMPLE
	  Python dictionaries are, of course, simply key-value
	  pairs. Users from other languages may recognize this data type
	  as hashes or associative arrays.

	  Dictionary keys are represented in YAML as strings terminated
	  by a trailing colon. Values are represented by either a string
	  following the colon, separated by a space:
	  
		  my_key: my_value
	  or
		  my_key:
			my_value
	  #+END_EXAMPLE
   3. 减号
	  #+BEGIN_EXAMPLE
	  To represent lists of items, a single dash followed by a space
	  is used. Multiple items are a part of the same list as a
	  function of their having the same level of indentation.

	  - list_value_one
	  - list_value_two
	  - list_value_three

	  my_dictionary:
		- list_value_one
		- list_value_two
		- list_value_three
	  #+END_EXAMPLE
** SLS
   YAML，Jinja
** Highstate
** States Module
* 管理实践
* 实践案例
** 安装Tomcat
    #+BEGIN_SRC sh
mkdir -p /srv/salt/{jdk,tomcat}
mkdir /srv/salt/jdk/files
	#+END_SRC
	安装jdk的salt SLS文件
    #+BEGIN_SRC sh
cat /srv/salt/jdk/install.sls
jdk-install:
  file.managed:
    - name: /usr/local/src/jdk-8u45-linux-x64.tar.gz
    - source: salt://jdk/files/jdk-8u45-linux-x64.tar.gz
    - user: root
    - group: root
    - mode: 755
  cmd.run:
    - name: cd /usr/local/src && tar -xf jdk-8u45-linux-x64.tar.gz && mv jdk1.8.0_45 /usr/local/jdk && chown -R root:root /usr/local/jdk
    - unless: test -d /usr/local/jdk
    - require:
      - file: jdk-install

jdk-config:
  file.append:
    - name: /etc/profile
    - text:
      - export JAVA_HOME=/usr/local/jdk
      - export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH
      - export CLASSPATH=.$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$JAVA_HOME/lib/tools.jar
	#+END_SRC

	安装tomcat的SLS文件，
    #+BEGIN_SRC sh
mkdir /srv/salt/tomcat/files
cat /srv/salt/tomcat/install.sls
include:
  - jdk.install

tomcat-install:
  file.managed:
    - name: /usr/local/apache-tomcat-8.0.23.tar.gz
    - source: salt://tomcat/files/apache-tomcat-8.0.23.tar.gz
    - user: root
    - group: root
    - mode: 755
  cmd.run:
    - name: cd /usr/local/src && tar -xf apache-tomcat-8.0.23.tar.gz && mv apache-tomcat-8.0.23 /usr/local/tomcat && chown -R root:root /usr/local/tomcat
    - unless: test -d /usr/local/tomcat
    - require:
      - file: tomcat-install

tomcat-config:
  file.append:
    - name: /etc/profile
    - text:
      - export: TOMCAT_HOME=/usr/local/tomcat
  #+END_SRC

	接下来写top文件，
    #+BEGIN_SRC sh
cat /srv/salt/top.sls
base:
  '*':
    - tomcat.install
	#+END_SRC

	接下来在Master端执行，
    #+BEGIN_SRC sh
salt '*' state.highstate
salt '*' saltutil.running
	#+END_SRC
** 安装Zabbix
	可以先使用手工的方式安装Zabbix，一般的流程是：
	1. 安装软件包
	   #+BEGIN_SRC sh
yum install -y zabbix22-agent
	   #+END_SRC
	2. 修改配置
	   #+BEGIN_SRC sh
Server=<zabbix_server_ip>
	   #+END_SRC
	3. 启动服务

    如果使用saltstack来安装Zabbix，也是这样的流程。
	1. 安装软件包 - pkg模块
	2. 修改配置 - file模块
	3. 启动服务 - service模块

	接下来到Master端，书写SLS文件，
	#+BEGIN_SRC sh
cd /etc/salt/states
vim init/zabbix_agent.sls
zabbix_agent:
  pkg.installed:
    - name: zabbix22-agent

  file.managed:
    - name: /etc/zabbix_agentd.conf
    - source: salt://init/files/zabbix_agentd.conf
    - user: root
    - group: root
    - mode: 644

  service.running:
    - name: zabbix-agentd
    - enable: True  # 设置开机自启动
    - reload: True  # 服务要支持reload才行，Zabbix好像不支持reload。如果不使用reload，默认是restart
    - watch:
      - file: zabbix_agent # 要监视的文件是ID名称
	#+END_SRC
	
	top.sls文件的内容，
	#+BEGIN_SRC sh
[root@mysql01 states]# cat top.sls 
base:
  '(mysql02|nfs01).lavenliu.com':
    - match: pcre
    - init.pkg
    - init.zabbix_agent
	#+END_SRC

	可以使用state.highstate测试运行，
	#+BEGIN_SRC sh
[root@mysql01 states]# salt '*' state.highstate test=True
mysql02.lavenliu.com:
----------
          ID: pkg.init
    Function: pkg.installed
        Name: mtr
      Result: True
     Comment: Package mtr is already installed.
     Started: 17:23:54.897325
    Duration: 2341.698 ms
     Changes:   
----------
          ID: pkg.init
    Function: pkg.installed
        Name: tree
      Result: True
     Comment: Package tree is already installed.
     Started: 17:23:57.239934
    Duration: 1.972 ms
     Changes:   
----------
          ID: zabbix_agent
    Function: pkg.installed
        Name: zabbix22-agent
      Result: True
     Comment: Package zabbix22-agent is already installed.
     Started: 17:23:57.242189
    Duration: 1.413 ms
     Changes:   
----------
          ID: zabbix_agent
    Function: file.managed
        Name: /etc/zabbix_agentd.conf
      Result: None
     Comment: The file /etc/zabbix_agentd.conf is set to be changed
     Started: 17:23:57.252196
    Duration: 23.85 ms
     Changes:   
              ----------
              diff:
                  ---  
                  +++  
                  @@ -5,7 +5,7 @@
                   
                   ### Option: PidFile
                   #	Name of PID file.
                  -#
                  +# hehe
                   # Mandatory: no
                   # Default:
                   PidFile=/var/run/zabbix/zabbix_agentd.pid
----------
          ID: zabbix_agent
    Function: service.running
        Name: zabbix-agentd
      Result: None
     Comment: Service zabbix-agentd is set to start
     Started: 17:23:57.277530
    Duration: 92.061 ms
     Changes:   

Summary
------------
Succeeded: 5 (unchanged=2, changed=1)
Failed:    0
------------
Total states run:     5
nfs01.lavenliu.com:
----------
          ID: pkg.init
    Function: pkg.installed
        Name: mtr
      Result: True
     Comment: Package mtr is already installed.
     Started: 17:24:15.457074
    Duration: 2255.713 ms
     Changes:   
----------
          ID: pkg.init
    Function: pkg.installed
        Name: tree
      Result: True
     Comment: Package tree is already installed.
     Started: 17:24:17.713521
    Duration: 1.991 ms
     Changes:   
----------
          ID: zabbix_agent
    Function: pkg.installed
        Name: zabbix22-agent
      Result: None
     Comment: The following packages are set to be installed/updated: zabbix22-agent
     Started: 17:24:17.715807
    Duration: 7547.875 ms
     Changes:   
----------
          ID: zabbix_agent
    Function: file.managed
        Name: /etc/zabbix_agentd.conf
      Result: None
     Comment: The file /etc/zabbix_agentd.conf is set to be changed
     Started: 17:24:25.276305
    Duration: 10.364 ms
     Changes:   
              ----------
              newfile:
                  /etc/zabbix_agentd.conf
----------
          ID: zabbix_agent
    Function: service.running
        Name: zabbix-agentd
      Result: False
     Comment: The named service zabbix-agentd is not available
     Started: 17:24:25.288333
    Duration: 18.668 ms
     Changes:   

Summary
------------
Succeeded: 4 (unchanged=2, changed=1)
Failed:    1
------------
Total states run:     5
	#+END_SRC

	如果测试没有问题，可以直接来执行了，
	#+BEGIN_SRC sh
[root@mysql01 states]# salt '*' state.highstate
	#+END_SRC

	继续，把zabbix_agentd.conf文件设置成模板，把Server一行设置成一个变量，
	#+BEGIN_SRC sh
Server={{ Zabbix_Server }}
	#+END_SRC

	状态配置文件也需要修改，
	#+BEGIN_SRC sh
zabbix_agent:
  pkg.installed:
    - name: zabbix22-agent

  file.managed:
    - name: /etc/zabbix_agentd.conf
    - source: salt://init/files/zabbix_agentd.conf
    - template: jinja
    - defaults:
      Zabbix_Server: {{ pillar['zabbix-agent']['Zabbix_Server'] }}
    - user: root
    - group: root
    - mode: 644

  service.running:
    - name: zabbix-agentd
    - enable: True
    - reload: True
    - watch:
      - file: zabbix_agent
	#+END_SRC

	接下来设置Pillar，
	#+BEGIN_SRC sh
vim /etc/salt/pillar/init/zabbix_agent.sls
zabbix-agent:
  Zabbix_Server: 192.168.20.158
	#+END_SRC

	为了让Pillar生效，需要在Pillar的top.sls文件中指定，
	#+BEGIN_SRC sh
cat /etc/salt/pillar/top.sls
base:
  '*':
    - init.rsyslog
    - init.zabbix_agent
	#+END_SRC

	接下来就可以执行了，
	#+BEGIN_SRC sh
salt '*' state.highstate 
	#+END_SRC
** 安装PHP
	基本的流程：
	1. 使用file模块，把源码文件传至minion端
	2. 安装依赖包
	   #+BEGIN_SRC sh
lamp-configure:
  pkg.installed:
    - names:
      - gcc
      - gcc-c++
      - glibc
      - make
      - autoconf
      - libjpeg-turbo
      - libjpeg-turbo-devel
      - libpng
      - libpng-devel
      - freetype
      - freetype-devel
      - libxml2
      - libxml2-devel
      - zlib
      - zlib-devel
      - libcurl
      - libcurl-devel
      - openssl
      - openssl-devel
	   #+END_SRC
	3. 使用cmd.run模块
	   1. 条件判断：如果php已安装，那么就不执行，2. files
	4. 
	#+BEGIN_SRC sh
include:
  - init.pkg

php-install:
  file.managed:
    - name: /usr/local/src/php-5.5.33.tar.gz
    - source: salt://php/files/php-5.5.33.tar.gz
    - user: root
    - group: root
    - mode: 755
  cmd.run:
    - name: cd /usr/local/src && tar -xf php-5.5.33.tar.gz && cd php-5.5.33 && ./configure
    - unless: test -d /usr/local/php-fastcgi
  require:
    - file: php-install
    - pkg.installed: php-install

pdo-plugin:
  cmd.run:
    - name: cd /usr/local/src/php-5.5.33/ext/pdo_mysql/ && /usr/local/php-fastcgi/bin/
    - unless: test -f /usr/local/php-fastcgi/lib/php/extensions/no-debug-non-zts-xx
  require:
    - cmd: php-install
	#+END_SRC

	接着在top.sls里注册php，
	#+BEGIN_SRC sh

	#+END_SRC
* 常用模块
** service
** saltutil
* salt-run
   查看哪些Minion端是否连接Master，
   #+BEGIN_SRC sh
salt-run manage.status
down:
up:
    - mysql02.lavenliu.com
    - nfs01.lavenliu.com
# 这里的up和down结果是执行了test.ping后的结果
   #+END_SRC

   更多的操作，
   #+BEGIN_SRC sh
[root@mysql01 ~]# salt-run manage.down
[root@mysql01 ~]# salt-run manage.up
- mysql02.lavenliu.com
- nfs01.lavenliu.com
[root@mysql01 ~]# salt-run manage.versions
Master:
    2015.5.8
Up to date:
    ----------
    mysql02.lavenliu.com:
        2015.5.8
    nfs01.lavenliu.com:
        2015.5.8
   #+END_SRC
* salt的job管理
   可以在命令行使用-v参数，查看job的详细信息，
   #+BEGIN_SRC sh
[root@mysql01 ~]# salt -v '*' test.ping 
Executing job with jid 20160509091002352851
-------------------------------------------

nfs01.lavenliu.com:
    True
mysql02.lavenliu.com:
    True
   #+END_SRC

   可以使用saltutil实用工具，
   #+BEGIN_SRC sh
salt '*' saltutil.running
[root@mysql01 ~]# salt '*' saltutil.running
mysql02.lavenliu.com:
    |_
      ----------
      arg:
      fun:
          state.highstate
      jid:
          20160509091156948909
      pid:
          1442
      ret:
      tgt:
          *
      tgt_type:
          glob
      user:
          root
nfs01.lavenliu.com:
    |_
      ----------
      arg:
          - 20160509091156948909
      fun:
          saltutil.find_job
      jid:
          20160509091201986948
      pid:
          1284
      ret:
      tgt:
          *
      tgt_type:
          glob
      user:
          root
    |_
      ----------
      arg:
      fun:
          state.highstate
      jid:
          20160509091156948909
      pid:
          1246
      ret:
      tgt:
          *
      tgt_type:
          glob
      user:
          root
   #+END_SRC

   可以使用kill_job来杀掉进程，
   #+BEGIN_SRC sh
[root@mysql01 ~]# salt '*' saltutil.kill_job 20160509091156948909
mysql02.lavenliu.com:
    Signal 9 sent to job 20160509091156948909 at pid 1442
nfs01.lavenliu.com:
    Signal 9 sent to job 20160509091156948909 at pid 1246
[root@mysql01 ~]# salt '*' saltutil.running
mysql02.lavenliu.com:
nfs01.lavenliu.com:
   #+END_SRC
* salt-ssh
   如果不想在Minion端安装salt-minion，可以使用salt-ssh，只要机器之间的
   SSH是通的，就可以使用salt-ssh工具了。可以不用安装salt-master，因为
   salt-ssh不依赖salt-master。salt-ssh的配置文件为/etc/salt/roster，

   使用salt-ssh的密钥验证。

   #+BEGIN_SRC sh
# 修改相应的配置如下
mysql02.lavenliu.com:
  host: 192.168.20.159
  user: root
  passwd: 111111
nfs01.lavenliu.com:
  host: 192.168.20.156
  user: root
  passwd: 111111
   #+END_SRC
   可以执行，
   #+BEGIN_SRC sh
[root@mysql01 ~]# salt-ssh '*' test.ping
mysql02.lavenliu.com:
    True
nfs01.lavenliu.com:
    True

[root@mysql01 ~]# salt-ssh '*' cmd.run "df -h"
nfs01.lavenliu.com:
    Filesystem      Size  Used Avail Use% Mounted on
    /dev/sda2        15G  3.0G   11G  22% /
    tmpfs           238M   12K  238M   1% /dev/shm
    /dev/sda1       194M   30M  155M  16% /boot
mysql02.lavenliu.com:
    Filesystem      Size  Used Avail Use% Mounted on
    /dev/sda2        15G  7.0G  6.8G  51% /
    tmpfs           743M   12K  743M   1% /dev/shm
    /dev/sda1       194M   30M  155M  16% /boot
   #+END_SRC
* 遇到的问题
** DNS
   要有一个内网DNS。
** Minion端没有返回结果
** 迁移Master到性能更好的机器上
   1. 原Master批量改变所有Minion端的配置文件里的："master: vvv.xxx.yyy.zzz"
   2. 打包原Master的/etc/salt/目录并传递到新的Master上
   3. 启动master进程
** SaltStack之returner接口
	默认情况下，Master发送命令到Minion端，Minion端将执行结果返回给
	Master。但SaltStack的returner接口允许将结果发送给任意系统。

	#+BEGIN_EXAMPLE
	http://docs.saltstack.com/en/latest/ref/returners/index.html
	#+END_EXAMPLE

	使用MySQL保存Minion的返回值：
	1. 修改minion的配置文件
	   #+BEGIN_EXAMPLE
	   mysql.host: 'vvv.xxx.yyy.zzz'
	   mysql.user: 'salt'
	   mysql.pass: 'xxxxxx'
	   mysql.db: 'salt'
	   mysql.port: 3306
	   #+END_EXAMPLE

	2. 创建数据库
	   #+BEGIN_EXAMPLE
	   # pip install python-mysqldb
CREATE DATABASE  `salt`
DEFAULT CHARACTER SET utf8
DEFAULT COLLATE utf8_general_ci;

USE `salt`;

--
-- Table structure for table `jids`
--

DROP TABLE IF EXISTS `jids`;
CREATE TABLE `jids` (
  `jid` varchar(255) NOT NULL,
  `load` mediumtext NOT NULL,
  UNIQUE KEY `jid` (`jid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
CREATE INDEX jid ON jids(jid) USING BTREE;

--
-- Table structure for table `salt_returns`
--

DROP TABLE IF EXISTS `salt_returns`;
CREATE TABLE `salt_returns` (
  `fun` varchar(50) NOT NULL,
  `jid` varchar(255) NOT NULL,
  `return` mediumtext NOT NULL,
  `id` varchar(255) NOT NULL,
  `success` varchar(10) NOT NULL,
  `full_ret` mediumtext NOT NULL,
  `alter_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  KEY `id` (`id`),
  KEY `jid` (`jid`),
  KEY `fun` (`fun`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Table structure for table `salt_events`
--

DROP TABLE IF EXISTS `salt_events`;
CREATE TABLE `salt_events` (
`id` BIGINT NOT NULL AUTO_INCREMENT,
`tag` varchar(255) NOT NULL,
`data` mediumtext NOT NULL,
`alter_time` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
`master_id` varchar(255) NOT NULL,
PRIMARY KEY (`id`),
KEY `tag` (`tag`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
	   #+END_EXAMPLE
** event
	event是一个本地的ZeroMQ PUB Interface，event是一个开放的系统，用于
	发送信息通知salt或其他的操作系统。

	每个event都有一个标签。事件标签允许快速置顶过滤事件。除了标签之外，
	每个事件都有一个数据结构。这个数据结构是一个dict类型，其中包含关于
	事件的信息。

	#+BEGIN_EXAMPLE
import salt.utils.event
event = salt.utils.event.MasterEvent('/var/run/salt/master')
for eachEvent in event.iter_events(full=True):
	print eachEvent
	print "-------"
	#+END_EXAMPLE
** 学习方法
   两种学习方法：
   1. 盖房子
   2. 滚雪球
* Salt Essentials
  + P61
	#+BEGIN_EXAMPLE
	Additional Remote Execution Details
	#+END_EXAMPLE
