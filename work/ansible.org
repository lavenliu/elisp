#+TITLE: Ansible自动化配置管理
#+AUTHOR: LavenLiu
#+DATE: 2015-09-27
#+EMAIL: ldczz2008@163.com 

#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper,11pt]
#+LaTeX_HEADER: \usepackage[top=2.1cm,bottom=2.1cm,left=2.1cm,right=2.1cm]{geometry}
#+LaTeX_HEADER: \setmainfont[Mapping=tex-text]{Times New Roman}
#+LaTeX_HEADER: \setsansfont[Mapping=tex-text]{Tahoma}
#+LaTeX_HEADER: \setmonofont{Courier New}
#+LaTeX_HEADER: \setCJKmainfont[BoldFont={Adobe Heiti Std},ItalicFont={Adobe Kaiti Std}]{Adobe Song Std}
#+LaTeX_HEADER: \setCJKsansfont{Adobe Heiti Std}
#+LaTeX_HEADER: \setCJKmonofont{Adobe Fangsong Std}
#+LaTeX_HEADER: \punctstyle{hangmobanjiao}
#+LaTeX_HEADER: \usepackage{color,graphicx}
#+LaTeX_HEADER: \usepackage[table]{xcolor}
#+LaTeX_HEADER: \usepackage{colortbl}
#+LaTeX_HEADER: \usepackage{listings}
#+LaTeX_HEADER: \usepackage[bf,small,indentafter,pagestyles]{titlesec}
#+LaTeX_HEADER: \renewcommand{\baselinestretch}{1.38}
#+LaTeX_HEADER: \setlength{\baselineskip}{20pt}

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="css/style2.css" />

#+OPTIONS: ^:nil

* Ansible
* 安装Ansible
   安装Ansible很简单，
   #+BEGIN_SRC sh
yum install -y ansible
   #+END_SRC
   
   #+BEGIN_EXAMPLE
   Suse11sp2:
   python -V
   2.6

   使用系统自带的python2.6版本，在安装其他包时，一切顺利。
   但在启动ansible时，提示python版本不对。所以，安装过程
   中，使用了python2.7.8的版本。以后编译其他依赖包时，显示
   的使用python2.7来进行编译安装即可。
   
   安装新版本的python，版本为2.7.8

   依赖包
   + python2.7.8
	 configure --prefix=/usr/local
	 make 
	 make install

   + six-1.9.0.tar.gz
	 tar -xf six-1.9.0.tar.gz
	 python2.7 setup.py install

   + libyaml
	 tar -xf yaml-0.1.5.tar.gz
	 ./configure
	 make
	 make install

   + pyyaml
	 tar -xf PyYAML-3.11.tar.gz
	 python2.7 setup.py test
	 python2.7 setup.py install

   + setuptools
	 tar -xf setuptools-17.1.tar.gz
	 python2.7 setup.py install
   
   + markupsafe
	 tar -xf MarkupSafe-0.23.tar.gz
	 python2.7 setup.py install 

   + jinja2
	 tar -xf Jinja2-2.7.3.tar.gz
	 python2.7 setup.py install

   + pycrypt
	 tar -xf pycrypto-2.6.1.tar.gz
	 python2.7 setup.py install 

   + ecdsa
	 tar -xf ecdsa-0.13.tar.gz
	 python2.7 setup.py install
   
   + paramiko
	 upzip -xf paramiko-master.zip
	 python2.7 setup.py install

   + simplejson-3.7.3.tar.gz
	 python2.7 setup.py install

   + ansible-1.7.2
	 unzip ansible-1.7.2.zip
	 python2.7 setup.py install

   mkdir /etc/ansible
   cp ansible-1.7.2/examples/ansible.cfg /etc/ansible
   cp ansible-1.7.2/examples/hosts /etc/ansible
   #+END_EXAMPLE
* 测试环境
  | 主机名                | 操作系统        |         IP地址 | 备注   |
  |-----------------------+-----------------+----------------+--------|
  | master01.lavenliu.com | CentOS6.5 64bit | 192.168.20.134 | 主控端 |
  | minion01.lavenliu.com | CentOS6.5 64bit | 192.168.20.135 | 被控端 |
  | minion02.lavenliu.com | CentOS6.5 64bit | 192.168.20.136 | 被控端 | 
* 配置Ansible
* Ansible基本使用
** Ansible无密码通信
   确定我们的ansible可以正常使用，接下来，我们准备几台测试机器。由于
   ansible是无agent的配置管理工具，在客户端无需安装任何额外程序，使用
   SSH协议进行通信，而SSH是默认安装的。
   
   为了今后方便进行配置管理，我们需要使用SSH无密码进行通信。本测试的几
   台主机及主机名为：
   
   #+BEGIN_HTML
   <center>
   <table border="6px">
   <caption>Ansible测试环境</caption>
   <tr>
       <th>主机</th>
       <th>说明</th>
   </tr>
   <tr>
       <td>192.168.56.150</td>
       <td>主控端</td>
   </tr>
   <tr>
       <td>192.168.56.111</td>
       <td>被控端</td>
   </tr>
   <tr>
       <td>192.168.56.112</td>
       <td>被控端</td>
   </tr>
   </table>
   </center>
   #+END_HTML

   
   在主控端生成SSH密钥对，并把公钥分发到被控端的机器上。
   #+BEGIN_SRC sh
   # ssh-keygen -t rsa
   # ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.56.111
   # ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.56.112
   #+END_SRC

   以上配置完毕，我们来简单的使用一下。比如，ping测试一下我们的被控端是否
   存活。
   #+BEGIN_SRC sh
   # cat /etc/ansible/hosts
   [my1]
   192.168.56.111
   192.168.56.112
   
   # ansible my1 -m ping 
   192.168.56.111 | success >> {
   "changed": false, 
   "ping": "pong"
   }
   
   192.168.56.112 | success >> {
   "changed": false, 
   "ping": "pong"
   }
   
   命令说明：
   my1 -- ansible操作的对象，my1组里有2台机器
   -m  -- 表示使用的是ansible的哪个模块，默认是command模块
   #+END_SRC

** command模块
   使用command模块，可以执行一些比较简单的命令。command是ansible的默认
   模块，我们要在一些机器上执行命令，可以省略“command”关键字。如果命令
   里包含空格，需要使用引号以转义掉空格字符。较复杂的命令command模块并
   不支持，诸如，重定向操作、管道操作等复杂操作command模块就无能为力了。
   下面看一些简单的例子，
   #+BEGIN_SRC sh
   # ansible my1 -m command -a "uptime"
   192.168.56.111 | success | rc=0 >>
   15:50pm  up   1:01,  2 users,  load average: 0.04, 0.03, 0.05
   
   192.168.56.112 | success | rc=0 >>
   15:50pm  up   1:01,  2 users,  load average: 0.00, 0.01, 0.05
   
   命令说明：
   -m command -- 表示使用command模块
   -a         -- 表示模块的参数
   #+END_SRC
   
** shell模块
   shell模块与command模块类似，可以执行一些较为复杂的命令。支持诸如重定
   向及管道的操作。下面看一个简单的例子，
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "cat /etc/hosts |grep -v '^#'"
   192.168.56.111 | success | rc=0 >>
   127.0.0.1	localhost 
   192.168.56.111  puppetcamq1.local.site
   192.168.56.112  puppetcamq2.local.site
   192.168.56.202  puppetmaster
   192.168.56.203  puppetca
   
   192.168.56.112 | success | rc=0 >>
   127.0.0.1	    localhost 
   192.168.56.111	puppetslave
   #+END_SRC
** package模块
   Ansible有几种常见的包管理模块。比如Debian系列的系统上，使用的是apt包
   管理机制；RHEL系列的系统上，使用的是yum包管理机制；SLES系列的系统上，
   使用的是zypper包管理机制。那么，对应到Ansible中，对应的三个模块是apt
   模块、yum模块、zypper模块。三种模块的使用方式一样，这里就使用SUSE的
   zypper包管理方式。下面来看一个简单的例子，
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "service snmpd status"
   192.168.56.111 | FAILED | rc=1 >>
   service: no such service snmpd
   
   192.168.56.112 | FAILED | rc=1 >>
   service: no such service snmpd
   #+END_SRC

   以上说明，这两台机器并没有安装net-snmp软件包。接下来，我们要安装之。
   #+BEGIN_SRC sh
   # ansible my1 -m zypper -a "name=net-snmp state=present"
   192.168.56.112 | success >> {
   "changed": true, 
   "name": [
   "net-snmp"
   ], 
   "state": "present"
   }
   
   192.168.56.111 | success >> {
   "changed": true, 
   "name": [
   "net-snmp"
   ], 
   "state": "present"
   }
   #+END_SRC
   
   注：
   #+BEGIN_EXAMPLE
   如果使用的是yum方式，上述的命令应为：
   # ansible my1 -m yum -a "name=net-snmp state=present"

   如果使用的apt方式，上述的命令应为：
   # ansible my1 -m apt -a "name=net-snmp state=present"
   #+END_EXAMPLE

   以上，已经安装net-snmp软件包，但是还没有启动。验证一下？
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "service snmpd status"
   192.168.56.111 | FAILED | rc=3 >>
   Checking for service snmpd:..unused
   
   192.168.56.112 | FAILED | rc=3 >>
   Checking for service snmpd:..unused
   
   说明：
   在SUSE里，服务未启动，则是“unused”状态
   #+END_SRC
   
   如何启动刚刚的snmpd服务呢？接下来看看service模块。
   
** service模块
   服务已经安装却迟迟不启动，这如何是好？使用service模块可以轻松搞定。
   前面的步骤里，我们已经安装了net-snmp软件包，却还没有启动相应的snmpd
   服务。接下来，启动之，
   #+BEGIN_SRC sh
   # ansible my1 -m service -a "name=snmpd state=running"
   192.168.56.111 | success >> {
   "changed": true, 
   "name": "snmpd", 
   "state": "started"
   }
   
   192.168.56.112 | success >> {
   "changed": true, 
   "name": "snmpd", 
   "state": "started"
   }
   #+END_SRC

   根据输出，看上去是很美好，但是启动成功了吗？不会是在忽悠我们吧？你觉得
   很有必要进行验证一把，我也是这么认为的。
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "service snmpd status"
   192.168.56.111 | success | rc=0 >>
   Checking for service snmpd:..running
   
   192.168.56.112 | success | rc=0 >>
   Checking for service snmpd:..running
   #+END_SRC

   看来，Ansible并没有忽悠我们，确实把snmpd服务给启动了。但是这里的服务
   是要开机启动的，该怎么办呢？看看帮助信息有没有相关的设置呢？结果小白
   找到了enabled选项，可以满足此要求，试试看？试之前，小白觉得还是有必
   要进行检查一下，snmpd服务是不是已经开机自启了呢？我觉得不会，因为小
   白没有设置！
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "chkconfig -l |grep snmpd"
   192.168.56.111 | success | rc=0 >>
   snmpd           0:off  1:off  2:off  3:off  4:off  5:off  6:off
   
   192.168.56.112 | success | rc=0 >>
   snmpd           0:off  1:off  2:off  3:off  4:off  5:off  6:off
   #+END_SRC

   snmpd服务安装完毕，确实没有设置开机自启，看来小白很是不专业，这么简
   单的问题，却蒙不正确。接下来就查下帮助设置一下吧，可以使用enabled选
   项，
   #+BEGIN_SRC sh
   # ansible my1 -m service -a "name=snmpd enabled=yes"
   # ansible my1 -m shell -a "chkconfig -l |grep snmpd"
   192.168.56.111 | success | rc=0 >>
   snmpd           0:off  1:off  2:on   3:on   4:off  5:on   6:off
   
   192.168.56.112 | success | rc=0 >>
   snmpd           0:off  1:off  2:on   3:on   4:off  5:on   6:off
   #+END_SRC
** file模块
   file模块一般是对远程主机上的文件或目录进行操作的。可以创建软、硬链接，
   修改文件属组及权限等。下面看一个例子，把/etc/hosts文件链接到/tmp目录
   下，
   #+BEGIN_SRC sh
   # ansible my1 -m file -a "src=/etc/hosts dest=/tmp/hosts state=link"
   192.168.56.111 | success >> {
   "changed": true, 
   "dest": "/tmp/hosts", 
   "mode": "0777", 
   "owner": "root", 
   "src": "/etc/hosts", 
   "state": "link"
   }
   
   192.168.56.112 | success >> {
   "changed": true, 
   "dest": "/tmp/hosts", 
   "mode": "0777", 
   "owner": "root", 
   "src": "/etc/hosts", 
   "state": "link"
   }
   #+END_SRC
   
   接下来，验证一下是不是已经创建软链接了，
   
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "egrep -v '^#|^$' /tmp/hosts"
   192.168.56.111 | success | rc=0 >>
   127.0.0.1	    localhost 
   192.168.56.111  puppetcamq1.local.site
   192.168.56.112  puppetcamq2.local.site
   192.168.56.202  puppetmaster
   192.168.56.203  puppetca
   
   192.168.56.112 | success | rc=0 >>
   127.0.0.1	    localhost 
   192.168.56.111	puppetslave
   #+END_SRC

   有了以上输出，说明没有问题！file模块就介绍这么多吧！如果我们有需要向远
   程主机发送文件该怎么办呢？可以使用copy模块，接下来的一个小节，来感受一
   下copy模块。
   
** copy模块
   copy模块是用向远程主机推送文件或目录用的。在推送过程中，我们可以设置文
   件在远程主机上的一些属性，如所有者、所属组等。接下来看操作，首先在控制
   端准备test.sh文件，
   #+BEGIN_SRC sh
   # cat /root/test.sh 
   #!/bin/bash
   
   echo -n "Today is: " 
   date +%F\ %H:%M:%S
   
   echo -n "My name is: "
   hostname
   #+END_SRC
   然后，把文件推送到远程主机的/tmp目录下，并设置权限，
   #+BEGIN_SRC sh
   # ansible my1 -m copy -a "src=/root/test.sh \
   > dest=/tmp/test.sh owner=root group=root \
   > mode=0755"
   192.168.56.111 | success >> {
   "changed": true, 
   "dest": "/tmp/test.sh" 
   }
   
   192.168.56.112 | success >> {
   "changed": true, 
   "dest": "/tmp/test.sh" 
   }
   #+END_SRC
   
   根据输出，我们可以看出，在主控端的test.sh文件已经复制过去了，并且修
   改了相应的权限。小白不高兴再次去做验证了，接下来就直接执行这个脚本吧！
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "/tmp/test.sh"
   192.168.56.111 | success | rc=0 >>
   Today is: 2015-07-01 15:02:58
   My name is: puppetcamq1
   
   192.168.56.112 | success | rc=0 >>
   Today is: 2015-07-01 15:03:01
   My name is: puppetslave
   #+END_SRC

   小白由于好奇，这个脚本之所以可以执行成功，是因为我们指定了其权限为
   755，其文件的所有者、所属组及其他用户皆可执行该文件。接下来，设置其
   权限为644呢，是否可以执行呢？试试呗，试一下机器又不会爆炸，
   #+BEGIN_SRC sh
   # ansible my1 -m file -a "path=/tmp/test.sh mode=0644"
   192.168.56.111 | success >> {
   "changed": true, 
   "mode": "0644", 
   "owner": "root", 
   "path": "/tmp/test.sh", 
   "state": "file"
   }
   
   192.168.56.112 | success >> {
   "changed": true, 
   "mode": "0644", 
   "owner": "root", 
   "path": "/tmp/test.sh", 
   "state": "file"
   }
   #+END_SRC

   通过上述设置及其输出情况，我们可以看到，test.sh文件的权限已经修改为
   了644。执行一下吧，
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "/tmp/test.sh"
   192.168.56.111 | FAILED | rc=126 >>
   /bin/sh: /tmp/test.sh: Permission denied
   
   192.168.56.112 | FAILED | rc=126 >>
   /bin/sh: /tmp/test.sh: Permission denied
   #+END_SRC
   
   这样执行呢？
   
   #+BEGIN_SRC sh
   # ansible my1 -m shell -a "bash /tmp/test.sh"
   192.168.56.111 | success | rc=0 >>
   Today is: 2015-07-01 15:09:47
   My name is: puppetcamq1
   
   192.168.56.112 | success | rc=0 >>
   Today is: 2015-07-01 15:09:50
   My name is: puppetslave
   #+END_SRC

   这个例子很是无聊，主要是小白想让大家熟悉一下file模块而已。file模块是
   从本地主机向远程主机推送文件，可不可以从远程主机拉取文件呢？答案是可
   以的！可以使用fetch模块实现该需求。这里不再演示。
   
** lineinfile模块
** setup模块
   setup模块里包含了很多有用的变量。在执行playbooks时，这些变量可以被
   playbooks来调用，有了这些变量，可以编排复杂的任务。setup模块默认是输
   出所有远程主机上的变量信息，我们可以通过filter来过滤我们想要的信息。
   举个例子看看，如只显示网卡信息，
   #+BEGIN_SRC sh
   # ansible my1 -m setup -a "filter=ansible_eth[0-2]"
   192.168.56.112 | success >> {
   "ansible_facts": {
   "ansible_eth1": {
   "device": "eth1"
   }, 
   "ansible_eth2": {
   "device": "eth2"
   },
   }
   
   192.168.56.111 | success >> {
   "ansible_facts": {
   "ansible_eth0": {
   "device": "eth0", 
   }, 
   "ansible_eth1": {
   "device": "eth1"
   }
   }
   #+END_SRC
   
   #+BEGIN_SRC sh
   # ansible my1 -m setup -a "filter=ansible_kernel"
   192.168.56.112 | success >> {
   "ansible_facts": {
   "ansible_kernel": "3.0.13-0.27-default"
   }, 
   "changed": false
   }
   
   192.168.56.111 | success >> {
   "ansible_facts": {
   "ansible_kernel": "3.0.13-0.27-default"
   }, 
   "changed": false
   }
   #+END_SRC
* playbook
  playbook是由一个或多个“play”组成的列表，可以让它们联同起来按事先编排
  的机制执行；所谓task无非是调用ansible的一个module，而在模块参数中可
  以使用变量；模块执行是幂等的，这意味着多次执行是安全的，因为其结果均
  一致；
  #+BEGIN_EXAMPLE
  H:\U_bak\book-template>tree /f playbooks
  卷 GRMCULFRER_ 的文件夹 PATH 列表
  卷序列号为 B4FE-5315
  H:\U_BAK\BOOK-TEMPLATE\PLAYBOOKS
  │  site.yml
  │  hosts
  │
  ├─roles
  │  └─common
  │      ├─handlers
  │      │      main.yml
  │      │
  │      ├─tasks
  │      │      main.yml
  │      │
  │      ├─templates
  │      │      net-snmp.j2
  │      │      ntp.conf.j2
  │      │      snmpd.conf.j2
  │      │      zypper.repo.j2
  │      │
  │      └─vars
  │              main.yml
  │
  └─group_vars
		  all
  #+END_EXAMPLE
* 一些具体实例
  看了以上的介绍，接下来可以写一些简单的自动化脚本了。
** 自动化部署Java环境
   脚本一览：
   #+BEGIN_SRC sh
   # cat java.yml
   - hosts: my1
   tasks:
   - name : set JAVA_HOME env variable
     lineinfile : dest=/etc/profile regexp="^JAVA_HOME=" line="JAVA_HOME=/usr/local/jdk"
   - name : set CLASS_PATH env variable
     lineinfile : dest=/etc/profile regexp="^CLASS_PATH=" line="CLASS_PATH=$JAVA_HOME/lib:$JAVA_HOME/jre/lib"
   - name : append JAVA_HOME to PATH env variable
     lineinfile : dest=/etc/profile regexp="^PATH=\$PATH:\$JAVA_HOME" line="PATH=$PATH:$JAVA_HOME/bin"
   - name : export JAVA_HOME env variable
     lineinfile : dest=/etc/profile regexp="^export JAVA_HOME" line="export JAVA_HOME"
   - name : copy jdk package to target machine
     copy : src=/usr/local/src/jdk-8u65-linux-x64.tar.gz dest=/tmp/jdk.tar.gz
   - name : delete /usr/local/jdk if exists
     file : path=/usr/local/jdk state=absent
   - name : create /usr/local/jdk directory
     shell : cd /tmp && tar zxf jdk.tar.gz && mv jdk1.8.0_65 /usr/local/jdk
   #+END_SRC
